;(function(){var store=window.bpEditorDocs=window.bpEditorDocs||{};Object.assign(store,{"Best Practices":{"content":"## Best practices\nBest practice is a standard or set of guidelines that represent the efficient and effective way to produce an optimal result. This documentation will only cover best practice with Blackprint, it's also recommended to follow best practice for the programming language that you're going to use. By following the best practices you can avoid common vulnerability and decrease complicated code in the future.\n\nBlackprint's guidelines may be updated when there are new feature for Blackprint or we found a best way to do something.","branch":{"Performance":{"content":"## Performance\nBlackprint is awesome for quickly prototyping your application. But if everything is done in Blackprint and your application is using so many nodes and cable, things will looks complicated and performance slow down may occurs. Especially if you connect with nodes that have a large loop, lot of operation, complex math, or lots of output update you will need them to be simplified as a single custom node with native code.\n\nBlackprint shouldn't be used for **visual scripting** (except if you have code generator module), but instead should be used as **visual programming** utility (where each node is like a plug and play module).\n\nBut the choice is still yours depends on your application's cases, Blackprint will always try to improve performance internally as a visual programming tools.\n\n---\n\n### Hint\nBelow is few hint to help reduce performance impact for your application:\n1. Less node is better than many nodes\n    - Try to simplify multiple node into a single node with native code if possible\n    - Convert some of your function node to native code if possible\n2. Less data flow through cable is better\n    - Having so many output update may impact the performance (like for loop)\n3. Routed nodes is better as it can reduce data race on every output update\n4. Reuse the output data instead of cloning\n    - You can create/use reroute cable (double click cable) to help organizing your nodes flow\n5. Use **Blackprint Engine** only instead of **Blackprint Sketch** in production if you don't need an editor for your users\n    - Using **Blackprint Sketch** will bind some node's object properties to update HTML UI element, it's an additional unnecessary work for your application\n6. Reduce event listener registered on instance, node, or port\n    - And also avoid listening to any event with `*` except for debugging\n    - Usually port's `value` event will more often for being called\n7. When you're creating a module, try to compare your code with some alternative code and benchmark it and use the fastest one if possible\n    - For JavaScript you can use JSBench for benchmarking\n    - Example: `.forEach(...)` is slower than `for(let i=0; ...)`\n8. Lock the engine instance with `instance.lock()` on production\n    - This will disabling instance modification like createNode, deleteNode, dynamic cable connection, or port creation/deletion\n    - The engine will do some optimization, and the instance can't be unlocked after being locked"},"Security":{"content":"## Security\nFor your information, **Blackprint Engine** and **Sketch** didn't use any `eval` or `Function('eval')` for executing the nodes as Blackprint only handle the data flow between nodes and help you visualize it and manage it. But on this **Blackprint Editor**, `eval` is being used for: \n- This documentation's `<script>` content (triggered when you open this documentation)\n  - This documentation is made and open sourced on GitHub [repository](https://github.com/Blackprint/blackprint.github.io/tree/master/docs)\n- Creating a custom node with Monaco code editor (triggered when you click the execute button)\n  - It's a facilities from <a onclick=\"Modal.goto('/custom-node-editor')\">this editor</a>\n- ScarletsFrame's framework does use `Function(...)` when compiling HTML templates.\n\n### Creating HTML Template\nWhen you want to create a user interface template for Blackprint Sketch, it will use ScarletsFrame to help rendering your template into HTML elements. ScarletsFrame will automatically escape contents that being outputted from the mustache template, for the example:\n\n```html\n<div> {{ contentFromUser }} <div>\n\n<div attrs=\" {{ contentFromUser }} \"><div>\n```\n\nIf the user or untrusted content is being passed into `contentFromUser` like:\n```js\n'<script>alert(\"hello\")</script>'\n```\n\nIt would be escaped and will looks like this in raw HTML:\n```html\n<div> &lt;script&gt;alert(\"hello\")&lt;/script&gt; </div>\n\n<div attrs=\"\\x3Cscript>alert(&quot;hello&quot;)\\x3C/script>\"><div>\n```\n\nBelow is an evaluated example inside this editor, try inspect it with DevTools and ScarletsFrame's inspector:\n<div>\n\t<docs-security-test-vuln>\n\t\t<div attrs=\" {{ contentFromUser }} \"> {{ contentFromUser }} </div>\n\t</docs-security-test-vuln>\n</div>\n\nUsers will see it just like the original text, and it helps to prevent a script injection to your project from your template. But there are also some implementation that you **must avoid** like:\n\nUsing template inside event listener's attribute:\n```html\n<a onclick=\"{{ dynamicFunctionCall }}\"></a>\n\n<!-- Or also -->\n<a @click=\"{{ dynamicFunctionCall }}\"></a>\n```\n\nNot only for `click` event, but any event must avoid using a mustache template inside of it. Even mustache template also escape HTML on attributes, it doesn't strip out the text that may be a valid script content.\n\n---\n\n### Using dynamic HTML template\nThe framework also have dynamic template feature that can evaluate your template script with `{{@if ... }}` and `{{@exec ... }}`. If you use these feature, you must know how to escape and implement the template properly as it will be dangerous if it's generated a `<script>` tag from your users.\n\nWhen dealing with dynamic template and you want to output a HTML element from inside of it, you need to escape it with enclosed template `{[ ... ]}`. It's safe to use mustache template inside of it `{[ <a> {{ userContent }} </a> ]}`, just don't ever forget to avoid using mustache inside of event attributes.\n\n```js\n<div title=\"some-menu\">\n\t{{@exec\n\t\t// You can freely write your JavaScript inside this dynamic template\n\t\tif(user.loggedIn){\n\t\t\t{[ <a> {{ user.name }} </a> ]};\n\t\t}\n\t\telse {\n\t\t\t{[ <a> Click here to login </a> ]};\n\t\t}\n\n\t\t// If you returning a text here it will be not escaped, so becareful!\n\t\t// return \"\";\n\n\t\t// If you returning a element here you also need to be careful and escape the content! (if have any)\n\t\t// return document.createElement('div');\n\t}}\n</div>\n```\n\nWith the above template, if the `user.loggedIn` is `true` and `user.name` is `Alex <script>alert(\"hello\")</script>` it will return:\n```html\n<div title=\"some-menu\">\n\t<a> Alex &lt;script&gt;alert(\"hello\")&lt;/script&gt; </a>\n</div>\n```\n\nIf the `user.loggedIn` is `false` then it will return:\n```html\n<div title=\"some-menu\">\n\t<a> Click here to login </a>\n</div>\n```\n\nBelow is an evaluated example inside this editor, try inspect it with DevTools and ScarletsFrame's inspector:<br>\nYou can also change the Boolean manually from SF inspector.\n<div>\n\t<docs-security-test-vuln>\n\t\t<div>\n\t\t{{@exec\n\t\t\tif(user.loggedIn){\n\t\t\t\t{[ <a> {{ user.name }} </a> ]};\n\t\t\t}\n\t\t\telse {\n\t\t\t\t{[ <a> Click here to login </a> ]};\n\t\t\t}\n\t\t}}\n\t\t</div>\n\t</docs-security-test-vuln>\n</div>\n\n### Creating element from string\nWhen creating element dynamically from a string you must avoid using dynamic content from user or data received from backend that haven't been sanitized from the frontend side. For the example:\n\n```js\n$(document.body).append(\"<div>\" + dynamicContent + \"</div>\");\n```\n\nIf user of your backend server send a data that contain this string `<script>alert(\"hello\")<script>` in the `dynamicContent`, it will generate an element like this and being appended on `document.body`.\n\n```html\n<body>\n\t<div><script>alert(\"hello\")<script></div>\n<body>\n```\n\nThe example above may lead to script injection vulnerability for your application, so don't forget to sanitize any user input/content or backend data when creating element from a string. For the example when you're using sQuery from ScarletsFrame:\n\n```js\n$(document.body).append(\"<div>\" + $.escapeText(dynamicContent) + \"</div>\");\n```\n\nAfter using `$.escapeText`, you will get output like below in raw HTML.\n\n```html\n<body>\n\t<div>&lt;script&gt;alert(\"hello\")&lt;script&gt;</div>\n<body>\n```\n\nBelow is an evaluated example inside this editor, try inspect it with DevTools and ScarletsFrame's inspector:\n<div>\n\t<docs-security-escape-text></docs-security-escape-text>\n\t<script>\n\t\tsetTimeout(function(){\n\t\t\t$('docs-security-escape-text').append(\"<div>\" + $.escapeText('<script>alert(\"hello\")<script>') + \"</div>\");\n\t\t}, 1000);\n\t</script>\n</div>\n\n## Secure your application with Content Security Policy\nIt's recommended to have CSP enable for your site. Even you're 100% sure about your library or backend security, if you didn't enable this security then your client network or browser can still be vulnerable to script injection. You should only allow (whitelist) any network request into your trusted domain only and resource from unknown domain will be restricted by default. CSP can also help you mitigate any `eval` or `Function` usage in your application. It's very **not recommended** to use `eval` if the **string content is dynamic** and can coming from other source like user input, you should find alternative way instead and remove `eval`.\n\nIf you're disabling eval, **Blackprint Engine** must be used on production as **Blackprint Sketch** is using **ScarletsFrame** to help compiling HTML templates on the fly. Compiling HTML templates dynamically may use `Function(...)`.\n\nAs long the templates can't be manipulated or created dynamically by user input, doesn't execute user input, and the output is sanitized, it still safe.\n\n### CSP Example\nFor example and information please visit https://content-security-policy.com/<br>\nUltimately just make default to none and just enable/allow source that you recognize.\n\n```html\n<head>\n\t<meta http-equiv=\"Content-Security-Policy\" content=\"default-src none;\">\n</head>\n```"}}},"Code Generation":{"content":"## Code Generation\nCode generation can be used to convert your Blackprint instance into native code and can be run without Blackprint Engine. But please take a note that **the module/nodes need to have their code registered to the Blackprint code generation module**.\n\n> This feature still experimental and currently supported for JavaScript only. Because this project is targetting multiple language, please expect the generated code will be more longer/larger than a manually written code.\n\n## How to use\nCode generation module is separated from the sketch or engine module. To use it you must import the codegen module first.\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/@blackprint/code-generation@0.1.1/dist/codegen.min.js\" crossorigin=\"anonymous\"></script>\n```\n\n### Register code\nThe code generation need to be registered with `registerCode(namespace, class)`. Some function name of the target language like `js, php, csharp` is reserved.\n\nBelow is a simple example of the code registration for `Data/Boolean/Compare/And` node.\n\n```js\nBlackprint.registerCode('Data/Boolean/Compare/And',\nclass extends Blackprint.Code {\n\tstatic routeIn = Blackprint.CodeRoute.MustHave;\n\tstatic routeOut = Blackprint.CodeRoute.MustHave;\n\n\t// routes == { traceRoute, routeIn, routeOut }\n\tjs(routes){\n\t\treturn {\n\t\t\tcode: `Output.Value = Input[\"0\"] && Input[\"1\"];`,\n\t\t};\n\t}\n\n\tcsharp(routes){ return this.php(routes); }\n\tphp(routes){\n\t\treturn {\n\t\t\tcode: `Output[\"Value\"] = Input[\"0\"] && Input[\"1\"];`,\n\t\t};\n\t}\n\n\tpython3(routes){\n\t\treturn {\n\t\t\tcode: `Output[\"Value\"] = Input[\"0\"] and Input[\"1\"]`,\n\t\t};\n\t}\n\n\tgolang(routes){\n\t\treturn {\n\t\t\tcode: `Output.Set(\"Value\", Input.Get(\"0\").(bool) && Input.Get(\"1\").(bool))`,\n\t\t};\n\t}\n\n\trust(routes){\n\t\treturn {\n\t\t\tcode: `output.set(\"Value\", input.get::<bool>(\"0\").unwrap() && input.get::<bool>(\"1\").unwrap());`,\n\t\t};\n\t}\n});\n```\n\n### Generate codes\nCurrently this editor doesn't provide a button to generate code from the instance, but you can call the generator function with code below\n\n```js\n// 'CurrentSketch' is either Blackprint.Sketch or Blackprint.Engine\n// 'js' is target language\n// 'MyProgram' is variable name for storing the generated codes's exports\nBlackprint.Code.generateFrom(CurrentSketch, 'js', 'MyProgram');\n```"},"Custom Nodes":{"content":"<center>\nBlackprint is designed to be modular and it has relation like below:\n\n![brave_kJ1dlxFYQI](https://user-images.githubusercontent.com/11073373/185061030-a0bd75e0-e665-4462-8bdc-463e1945039b.jpg)\n</center>\n\n**Node** is the main component for Blackprint and any function/properties in it's class should be considered as private or internal. **Node** will have an **Interface** that can help you or other developers interact with your **Node**, just think like an **API**. In the browser environment, especially on nodes editor **(Sketch)** you can customize your node's user interface with **Sketch Interface**. Sketch Interface can also have it's own handler for browser only, like listening to mouse click or other browser event. When the module get imported on non-browser environment the **Sketch Interface** script (`.sf.mjs`) will not be loaded for them.\n\n> In the browser environment, **Sketch Interface** script will not get loaded if you didn't load/import `@blackprint/sketch`\n\n## Register Node\nThis registration is _**required**_.<br>\nEvery node is registered in a namespace and every namespace need to be capitalized. Don't use symbol for the namespace except `.`, `_`, `/`. In some programming language, the dot `.` symbol will be converted into underscore `_`.\n\n```js\nBlackprint.registerNode(\"My/Custom/Node\",\nclass extends Blackprint.Node {\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// This call is required, you can also leave this empty to use default interface\n\t\tthis.setInterface(\"BPIC/My/Custom/Node\");\n\t\tthis.iface === (/* Object reference from .registerInterface() */);\n\n\t\t// Function below will be available if the instance is Blackprint.Engine or Blackprint.Sketch\n\t\tthis.node.helloEngine();\n\n\t\t// Function below will be available if the instance is Blackprint.Sketch only\n\t\tthis.node.helloSketch();\n\t}\n\n\t// This function will be available for both Engine and Sketch node instance\n\thelloFromNode(){ return 123 }\n});\n```\n\n## Register Interface\nThis is an **optional** registration.<br>\nInterface registration is necessary if you want to use different user interface for the nodes, or giving an API for developers to interact with your node's functionality with code/scripts. Think of **node** is internal device/circuit and **interface** is something you can interact into.\n\nEvery interface is registered in a namespace, every namespace need to be capitalized and starts with `BPIC/...`. BPIC stands for `Blackprint Interface Component`.\n\n```js\nlet CustomNodeIFace;\n\nBlackprint.registerInterface(\"BPIC/My/Custom/Node\",\nCustomNodeIFace = class extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.node === (/* Object reference from .registerNode() */);\n\n\t\tthis.node.helloFromNode(); // => 123\n\t}\n\n\t// This function will be available for both Engine and Sketch node instance\n\thelloEngine(){ }\n});\n```\n\n## Register Sketch Interface\nThis is an **optional** registration and **can only be registered for Browser environment**.<br>\nYou can also just extends from the class you have registered with `Blackprint.registerInterface()`. The namespace also **must be** similar with the interface you have registered: `Blackprint.registerInterface('BPIC/A/B', ...) <-> Blackprint.Sketch.registerInterface('BPIC/A/B', ...)`.\n\n```js\nBlackprint.Sketch.registerInterface(\"BPIC/My/Custom/Node\", {\n\t// You can define your node's HTML on here\n\thtml: `<div>...</div>`\n\n\t// If you're using .sf file from Blackprint template\n\t// You can skip this second parameter and just replace it with class declaration\n\t// Blackprint.Sketch.registerInterface(\"BPIC/My/Custom/Node\", class extends ...)\n},\nclass extends CustomNodeIFace {\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.node === (/* Object reference from .registerNode() */);\n\n\t\tthis.node.helloFromNode(); // => 123\n\t}\n\n\t// This function will be available for Sketch node instance only\n\thelloSketch(){ }\n});\n```\n\nFor more information, let's navigate to other sub-documentation. To begin with, you can navigate with this order: `Create Module -> Node -> Port -> Interface -> Sketch Interface`.","branch":{"Create Module":{"content":"## Create from template\nTo begin creating nodes module, it's better to start from a template where it already include default settings, file, and compiler's configurations so you can just run the module server and start modify the module template. Blackprint CLI provide a tools for compiling, serving your module, and also can create template for you:\n\nYou can install the CLI globally\n```sh\n$ pnpm i -g @blackprint/cli-tools\n$ cd /your/project/folder\n$ blackprint create\n```\n\nOr install it locally, depends on your preferences\n```sh\n$ cd /your/project/folder\n$ pnpm i @blackprint/cli-tools\n$ npx blackprint create\n```\n\n### Module server for development\nThe `build` and `serve` command will watch for `blackprint.config.js` from current working directory and search deeper inside of `nodes` directory. So.. make sure you're not putting `node_modules` inside of `nodes` directory, or it will fill up your computer memory.\n\nTo use run the server, you can execute this command on the root of your project.\n```sh\n$ blackprint serve\n```\n\n**Blackprint Editor** also allow you to change it's module server for development purpose. To enable this feature you need to go to the sketch page and open the main menu **(Remote -> Module server)**. All you need to do is wait for the compiler to output your server URL like below and paste the `http://localhost:6790` into module server's input box on Blackprint Editor. After the editor get connected, you can start modifying your code and it will be hot reloaded on the editor.\n\n```sh\n[Browsersync] Access URLs:\n ------------------------------------\n    Local: http://localhost:6790\n ------------------------------------\n```\n\n![brave_k7lJX6nAiA](https://user-images.githubusercontent.com/11073373/185054909-77e2986a-482b-49e7-88e2-244daf0e48aa.jpg)\n\n> Please remember not to connect to untrusted server as it can hot reload the script and may be able to control this editor. This should only be used for development only, and this feature **only available on Development Mode**.\n\n### Build command\nIf you want to build the module without running a server, you can run this command on the root of your project:\n```sh\n$ blackprint build\n```\n\nTo minify the files for production, you can use `production` or `prod` build mode:\n```sh\n$ blackprint build prod\n```\n\nIf you installed the CLI locally with `package.json` on your project, you need to use `npx`:\n```sh\n$ npx blackprint build\n```\n\n### Project directory structure\nRequired directory structure:\n- `package.json` : Package/module information\n- `src/**/*.js` : Structured with node's namespace to make it easier to find the nodes by it's namespace\n- `example/*.json` : Examples that can be loaded from Blackprint Editor"},"Interface":{"content":"## Interface Registration\nInterface registration is optional but required if you want to provide a function or exposable property for other developer to your node, this allow your application and the node to talk each other.\n\nTo register an interface into Blackprint Engine, you need to prepare class that extends `Blackprint.Interface` and register it with `Blackprint.registerInterface(namespace, class)`.\n\n> Every interface must be registered in a namespace started with `BPIC/` and every namespace need to be capitalized. Don't use symbol for the namespace except `.`, `_`, `/`. In some programming language, the dot `.` symbol will be converted into underscore `_`.\n\nBPIC (`Blackprint Interface Component`) is a root namespace will help avoid conflict with internal namespace in the future.\n\n```js\nlet CustomNodeIFace; // You can store the class here in case if you want to export or use it on other script\n\nBlackprint.registerInterface(\"BPIC/My/Custom/Node\",\nCustomNodeIFace = class extends Blackprint.Interface {\n    // 'constructor' here is optional, only for Blackprint.Node that was required to have\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.node === (/* Object reference from .registerNode() */);\n\t}\n});\n```\n\nThere are several ways to obtain interface object after you created a node in the instance:\n\n```js\nlet instance = new Blackprint.Engine();\nawait instance.importJSON(...);\n\n// If you want to get list of the created iface\ninstance.ifaceList; // => [iface1, iface2, ...]\n\n// If you want to get iface by node id\ninstance.iface[\"ifaceId\"]; // => instanceof Blackprint.Interface\n\n// If you want to get references object by node id\nlet { Input, Output, IInput, IOutput } = instance.ref[\"ifaceId\"];\n```\n\n### Lifecycle order\n1. `constructor()`: called on constructing new node object\n2. `imported()`: called after new node was constructed\n3. `init()`: called after all nodes have been constructed, all data imported, and cables has been connected\n4. `destroy()`: called on node deletion from instance\n\n### Initialize interface after creation\nBlackprint will call `init()` function when everything is ready to be used, after all nodes have been constructed, all data imported, and cables has been connected. This `init()` function can be overriden when you registered an interface for sketch instance with `Blackprint.Sketch.registerInterface(...)`.\n\n```js\nclass extends Blackprint.Interface {\n\tinit(){\n\t\t// It's time to add event listener or some other initialization after node creations\n\t\t// Blackprint will call this function after `node.init()`\n\n\t\t// ====== Port Shortcut ======\n\t\tconst {\n\t\t\tIInput, IOutput, // Port interface\n\t\t\tInput, Output, // Port value\n\t\t} = this.ref;\n\n\t\t// Port interface: can be used for registering event listener\n\t\t// Port value: can be used for get/set the port value\n\t}\n}\n```\n\n### Handle data import on creation\nWhen you're creating a node either using `instance.importJSON({...})` or `instance.createNode(namespace, options)` sometime the JSON may contain saved data from optionally specify `data` field on `options` for `.createNode()`, Blackprint will call `iface.imported(data)` to let you process the data after node construction before initialization.\n\n```js\n// This is optional but recommended if you want to store data on your interface\nclass MyDataStructure {\n    constructor(iface){\n        this._iface = iface;\n    }\n\n\tget value(){ return this._value },\n\tset value(val){\n\t\tthis._value = val;\n\n\t\t// Add support for remote sync: node.syncOut(eventName, value);\n\t\t// The data will be received in: node.syncIn(event, value);\n\t\tthis._iface.node.syncOut('data.value', val);\n\t},\n}\n\nclass extends Blackprint.Interface {\n    constructor(node){\n        // Create a data storage, this data can be exported with `sketchInstance.exportJSON()`\n        this.data = new MyDataStructure(this);\n    }\n\n\timported(data){\n\t\t// A boolean indicating if this node is being imported/created\n\t\t// This will reset to false after this imported() has been called\n\t\tthis.importing === true;\n\n\t\t// This will only exist if \n\t\tdata instanceof Object;\n\n\t\t// Assign saved data into our iface.data\n\t\t// You shouldn't use \"this.data = data\" or it will replace the object\n\t\tObject.assign(this.data, data);\n\t}\n}\n```\n\n### Handle removed interface\nBlackprint will call `destroy()` when the node is being removed.\n\n```js\nclass extends Blackprint.Interface {\n\tdestroy(){\n        // You can remove event listener from here and do some clean up\n\t}\n}\n```\n\n## Add event listener into a interface\n|Event Name|Event Object|Description|\n|---|---|---|\n|`cable.connect`|`{ port: Port, target: Port, cable: Cable }`|Two ports were connected with a cable|\n|`cable.disconnect`|`{ port: Port, target: Port, cable: Cable }`|Two ports get disconnected each other|\n|`port.value`|`{ port: Port, target: Port, cable: Cable }`|There's new value update coming from output port|\n\nBelow is an example on how to register event on an interface:\n```js\n// Optional, but recommended to avoid re-register similar listener\nlet EventSlot = {slot: \"myLibraryName\"};\n\nclass extends Blackprint.Interface {\n\tinit(){\n        this.on('cable.connect', EventSlot, function(event){\n            event.port // => Port interface reference from this node\n            event.target // => Port interface reference from other node\n            event.cable // => Cable reference that connect two ports\n        });\n\t}\n}\n```"},"Node":{"content":"## Node Registration\nNode registration is required as this is the main part that will process the received data flow from Blackprint Engine. To register a node into Blackprint Engine, you need to prepare class that extends `Blackprint.Node` and register it with `Blackprint.registerNode(namespace, class)`.\n\n> Every node must be registered in a namespace and every namespace need to be capitalized. Don't use symbol for the namespace except `.`, `_`, `/`. In some programming language, the dot `.` symbol will be converted into underscore `_`.\n\n```js\n/**\n * Write your node's documentation here\n * @blackprint node\n * @summary write small description below the node's title here\n */\nBlackprint.registerNode(\"My/Custom/Node\",\nclass extends Blackprint.Node {\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// This call is required, you can also leave this empty to use default interface\n\t\tthis.setInterface(\"BPIC/My/Custom/Node\");\n\n\t\t// After calling above function, `this.iface` will have an reference to it's interface\n\t\tthis.iface === (/* Object reference from .registerInterface() */);\n\n\t\t// You can also change the title from here\n\t\tiface.title = 'My Title';\n\t}\n});\n```\n\n`@blackprint node` is required if you want the compiler to extract the documentation. Single line comment with `// ...` will not be extracted, please use `/** ... */` instead. For information about how to define port for your node, please go to **Custom Nodes -> Port** documentation. If you searching for how to create node for an instance, please go to **Engine** or **Sketch** documentation.\n\n### Lifecycle order\n1. `constructor()`: **Required**, called on constructing new node object\n2. `imported()`: called after new node was constructed\n3. `init()`: called after all nodes have been constructed, all data imported, and cables has been connected\n4. Data cycle\n\t- `update()`: called when current node receiving an data on input port\n\t- `request()`: called when other node is requesting data from current node's output port\n\t- `syncIn()`: called when the synchronizing with `node.syncOut()` for remote engine\n5. `destroy()`: called on node deletion from instance\n\n> Example code for every section below is a simplified version of implementation, you also need to add `constructor` function like example above for registering node. They are also optional, you can skip them if you don't need it.\n\n### Initialize node after creation\nBlackprint will call `init()` function when everything is ready to be used, after all nodes have been constructed, all data imported, and cables has been connected.\n\n```js\nclass extends Blackprint.Node {\n\tinit(){\n\t\t// It's time to add event listener or some other initialization after node creations\n\n\t\t// ====== Port Shortcut ======\n\t\tconst {\n\t\t\tIInput, IOutput, // Port interface\n\t\t\tInput, Output, // Port value\n\t\t} = this.ref;\n\n\t\t// Port interface: can be used for registering event listener\n\t\t// Port value: can be used for get/set the port value\n\t}\n}\n```\n\n### Handle data import on creation\nWhen you're creating a node either using `instance.importJSON({...})` or `instance.createNode(namespace, options)` sometime the JSON may contain saved data from optionally specify `data` field on `options` for `.createNode()`, Blackprint will call `node.imported(data)` to let you process the data after node construction before initialization.\n\n```js\n// Please see Custom Nodes -> Interface instead to see detailed example\nclass extends Blackprint.Node {\n\timported(data){\n\t\t// A boolean indicating if this node is being imported/created\n\t\t// This will reset to false after this imported() has been called\n\t\tthis.iface.importing === true;\n\n\t\t// This will only exist if we're importing JSON or using options that have `data` field\n\t\tdata instanceof Object;\n\t}\n}\n```\n\n### Handle data update from input port\nCallback when current input port's value was updated from the other node's output port. Adding `update()` function is more recomended than using event listener `port.value` or `value`. If you trigger `node.update()` manually somewhere on your code, you must trigger route out `node.routes.routeOut()` too.\n\n```js\nclass extends Blackprint.Node {\n\tupdate(cable){\n\t\t// Triggered when any output value from other node are updated\n\t\t// And this node's input connected to that output\n\t}\n}\n```\n\n### Handle data request from output port\nCallback when other node's input port are requesting current node's output value. This function will be useful if the data flow is started from the right side, where input port is asking output data from node on the left side.\n\n```js\nclass extends Blackprint.Node {\n\trequest(cable){\n\t\t// Triggered when other connected node is requesting\n\t\t// output from this node that have empty output\n\t}\n}\n```\n\n### Sync with remote node\nCallback when the node received data sync from remote node\n\n```js\nclass extends Blackprint.Node {\n\t// Add support for remote sync (this will receive data from .syncOut)\n\tsyncIn(eventName, value){\n\t\tif(eventName === 'data.value')\n\t\t\tthis.iface.data.value = value;\n\t}\n}\n```"},"Port":{"content":"## Defining port for a node\nPorts can be defined statically when registering a node with `Blackprint.registerNode()`. Input or output port is optional, you can also skip defining port if you want to create a node that doesn't need any data. Below is the example on how to define port:\n\n![brave_cLYl8ls0tx](https://user-images.githubusercontent.com/11073373/185162709-29a96350-5a83-42b3-9245-604c15ff8f9b.jpg)\n\n```js\n/**\n * Write your node's documentation here\n * @blackprint node\n * @summary write small description below the node's title here\n */\nBlackprint.registerNode(\"My/Node\",\nclass extends Blackprint.Node {\n\t// Define Input Port\n\tstatic input = {\n\t\t/** Write your port's documentation here */\n\t\tMyInputPort: Number, // This port will only accept Number data type\n\t};\n\n\t// Define Output Port\n\tstatic output = {\n\t\t/** Write your port's documentation here */\n\t\tMyOutputPort: String, // This port will only have String data type\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\t\tthis.setInterface();\n\t}\n});\n```\n\n## Port types\nIn JavaScript you can easily use the class constructor for the port's data type, like `String, Number, Object, RegExp`. Blackprint Engine will validate every cable connection and also validate the output data before the data reaching to the input port. But in some scenario where you create a library and didn't expose the class constructor, the other library will can't use the similar constructor and Blackprint will consider it's a different data type even it has a similar name `MyType` <-> `MyType`.\n\nWhile you define the port with class constructor, you may find JavaScript didn't have `Any` class constructor that can accept any data type. So if you want your port to accept any data type, you can use `Blackprint.Types.Any` as the data type.\n\n```js\nstatic input = {\n\tMyPort: Blackprint.Types.Any\n}\n```\n\n## Port features\nWhen defining port type with class constructor, it may only accept a single data type. In some scenario you may need port with extended feature like `Union` that can accept multiple data type or a port that can be called like a function with `Trigger`. Blackprint provides you this power and allow you to define port with `Blackprint.Port.{Feature}`.\n\n### ArrayOf\nThis port feature can contain multiple cable as input and the value will be array of `<type>`. It's only accept one type, not union. For union port please split it to different port to handle it.\n\n![brave_NUHB0jqZzj](https://user-images.githubusercontent.com/11073373/185188717-5edf8d10-c45e-4f91-92b9-c1a8a766b0f8.jpg)\n\n```js\n// Available only on Input port\nstatic input = {\n\tMyPort: Blackprint.Port.ArrayOf(Number)\n}\n```\n\n### Default\nThis port feature can contain default value for your defined data type.\n\n![brave_mM8w8bUuLq](https://user-images.githubusercontent.com/11073373/185188895-d35d24c0-0aa5-4297-a665-a3b5bf6bb6ca.jpg)\n\n```js\n// Available only on Input port\nstatic input = {\n\tMyPort: Blackprint.Port.Default(String, \"hello\")\n}\n```\n\n### Trigger\nThis port feature behaves like a function, other output port can call it like a function. You can also call this function manually from `node.ref.Input.MyPort()`.\n\n```js\n// Available only on Input port\nstatic input = {\n\tMyPort: Blackprint.Port.Trigger(function(port){\n\t\tconsole.log('MyPort was called');\n\t\tport.iface.node.doSomething();\n\t}),\n}\n```\n\nIf you want to trigger the Port.Trigger's function manually with a script, you can do it like below:\n```js\nclass extends Blackprint.Node {\n\tinit(){\n\t\tlet { Input } = this.ref;\n\t\tInput.MyPort.Exec();\n\t}\n}\n```\n\nOn the other node for the output port, you can define your port type as Function. If `MyPort` is connected with `MyOutput` port and you want to call `MyPort` from the output port with a script, you can call the output trigger with `node.ref.Output.MyOutput()`.\n\n```js\nstatic output = {\n\tMyOutput: Function,\n}\n```\n\n### Union\nThis port feature accept a single cable that compatible with multiple data type.\n\n```js\n// Available only on Input port\nstatic input = {\n\tMyPort: Blackprint.Port.Union([String, Number, Boolean])\n}\n```\n\n### Route\nWhile usually a node only allow you to use a single route cable output, this port feature can help you to create your own route port that can be connected to other route port. You can easily call it like a function `node.ref.Output.MyPort()`.\n\n> This port only available for output port\n```js\n// Available only on Output port\nstatic output = {\n\tMyPort: Blackprint.Port.Route\n}\n```\n\n### StructOf\nWhen you create a complex node usually you will encounter with many ports definition and often the port name can conflict each other. With this port feature you can define a port that can be splitted in a structural form. To split this port you can do it from the Sketch by right clicking the port and choose Split.\n\n> This port only available for output port\n```js\n// Available only on Output port\nstatic output = {\n\t// Port.StructOf(OriginalType, Structure)\n\tSpeed: Blackprint.Port.StructOf(Object, {\n\t\tX: { type: Number, field: 'x' },\n\t\tY: { type: Number, handle(data){ return data.y } },\n\t}),\n\tVelocity: Blackprint.Port.StructOf(Object, {\n\t\tX: { type: Number, field: 'x' },\n\t\tY: { type: Number, handle(data){ return data.y } },\n\t}),\n}\n```\n\nThe `Structure` for the code example above is formatted like below:\n```js\nBlackprint.Port.StructOf(TypeData, {\n\tPortName: { type: TypeData, [field || handle] },\n})\n```\n\n`field` and `handle` is optional, but one of them is required. It's used for extracting data from the original data, let's use the example from the previous image and assume the `Input.Speed` port is receiving data like below:\n\n```js\nInput.Speed = {\n\tx: 10,\n\ty: 20,\n}\n```\n\nOn splitted form of StructOf, you may find 2 port that being handled with `field` and `handle`. Both is do the same thing, extracting `x` and `y` but in different way. The 2 port then will be appended into the output port, and you will have:\n\n```js\nnode.ref.Output.SpeedX === 10\nnode.ref.Output.SpeedY === 20\nnode.ref.Output.Velocity === { ... } // Assume this haven't been splitted\n```\n\nOn unsplitted form, both of them will looks like below:\n\n![brave_eMQMnaxmy6](https://user-images.githubusercontent.com/11073373/185187691-93ee6d06-eab1-4ebd-a79b-9a6923d8031b.jpg)\n\nOn splitted form, both of them will looks like below:\n\n![brave_hr2FissKMU](https://user-images.githubusercontent.com/11073373/185187898-3e9aa909-b02b-4895-8d93-7fac70b0912d.jpg)\n\n`BP-*` name can be changed in the future, so please consider it's name as experimental/internal.\n\n---\n\n## Dynamically add port into node\n\n```js\nclass MyNode extends Blackprint.Node {\n\tstatic input = { PortName: Number };\n\tconstructor(){...}\n\n\t// Triggered when importing data on node creation\n\timported(data){\n\t\tlet portA = this.createPort('input', 'PortA', String);\n\t\tlet portB = this.createPort('input', 'PortB', Blackprint.Port.Arrayof(Number));\n\t}\n}\n```\n\n## Add component on port element\nThis feature may get changed and will not be documented for now, but in a plan to be documented.\n\n## Obtain connected cable list from a port\nCable list from a port can be obtained by using the port's interface `portInterface.cables`. Below is the example if you want to obtain cable list:\n\n```js\nclass MyNode extends Blackprint.Node {\n\t// Usually this will just have one cable, only ArrayOf type that can have multiple cable\n\tstatic input = { PortName: Number };\n\n\tconstructor(){...}\n\n\t// Triggered when the input port have a new value\n\tupdate(){\n\t\tlet { PortName } = this.ref.IInput;\n\t\tPortName.cables instanceof Array; // => [Cable, ...]\n\t}\n}\n```\n\n## Disconnect all cable from a port\n\n```js\nlet { iface1 } = instance.ref; // iface1 is the node ID\n\n// Disconnect all cables\niface1.IInput['MyInputPort'].disconnectAll();\n```\n\n## Connect ports\nTo connect ports, you need to obtain their port's interface first. One port from both `ref.IInput` and `ref.IOutput` is needed as input port can only be connected with output port. You can't connect input port with input port, and also you can't connect port that where the type data isn't compatible each other.\n\n```js\nlet { iface1, iface1 } = instance.ref; // iface1, iface1 is the node ID\n\n// Connect input with output port\niface1.IInput['MyInputPort'].connectPort(iface2.IOutput['MyOutputPort']);\n```\n\n## Add event listener into a port\n\n|Event Name|Event Object|Description|\n|---|---|---|\n|`value`|Input Port:<br>`{ port: Port, target: Port, cable: Cable }`<br>Output Port: `{ port: Port }`|There are value update on the port|\n|`call`|`null`|The `Port.Trigger` or port with `Function` type was called|\n|`connecting`|`{ target: Port, activate: Callback }`|A cable is trying to connect for the port|\n|`connect`|`{ port: Port, target: Port, cable: Cable }`|An cable was connected from the port|\n|`disconnect`|`{ port: Port, target?: Port, cable: Cable }`|An cable was disconnected from the port|\n\n```js\nclass MyNode extends Blackprint.Node {\n\tconstructor(instance){ ... }\n\n\t// We can listen for event on init()\n\tinit(){\n\t\tlet { IInput, IOutput } = this.ref;\n\n\t\t// Event listener can be registered for IInput, IOutput\n\t\tIInput.PortName1.on('value', Context.EventSlot, function(ev){\n\t\t\tconsole.log(\"PortName1:\", ev);\n\n\t\t\t// If have changed output port's value inside this listener\n\t\t\t// you may also need to trigger route out `iface.node.routes.routeOut()`\n\t\t})\n\n\t\t// When the port connected with other port\n\t\t.on('connect', Context.EventSlot, function({ port, target, cable }){})\n\n\t\t// When the port disconnected with other port\n\t\t.on('disconnect', Context.EventSlot, function({ port, target, cable }){});\n\n\t\tfunction myLongTask(callback){\n\t\t\tsetTimeout(()=> callback(true), 1000);\n\t\t}\n\n\t\t// When this port are trying to connect with other node\n\t\tIOutput.PortName2.on('connecting', Context.EventSlot, function({ port, target, activate }){\n\t\t\tmyLongTask(function(success){\n\t\t\t\tif(success) activate(true); // Cable will be activated\n\t\t\t\telse activate(false); // Cable will be destroyed\n\t\t\t});\n\n\t\t\t// Empty = is like we're not giving the answer now\n\t\t\tactivate(); // Mark as async\n\n\t\t\t// Or destroy it now\n\t\t\t// activate(false)\n\t\t});\n\n\t\t// ...\n\t}\n}\n```","branch":{"Cable":{"content":"Cable is a linker that can help passing data between linked ports. Usually the data flow will always from output into an input port. Even the cable is a lightweight component, **you shouldn't passing too many data or your application** performance will decreased. If possible you should create an object that can be modified from other node rather than re-passing the data one by one. That method will help decrease data passing between port and may improve your application performance.\n\nThe performance difference is not very large, and if you think your node is more suitable for having a port that passing many data to other port it's also okay. What I mean with \"many data\" is not like passing a very large array at once, but it's more like updating the port value more often than usual:\n\n```js\nlet { Output } = node.ref;\n\n// I don't mean like this, this one still okay and good practice\nOutput.Data = [x1, x2, x3, ....., x10000];\n\n// But updating data like this may affect the performance as more event will be triggered internally\nlet temp = [x1, x2, x3, ....., x10000];\nfor(let i = 0; i < temp.length; i++){\n\tOutput.Data = temp[i];\n}\n```\n\nWhy the performance is slower? when you updated the port value it will also trigger ports event for the port itself, and the node. It may also need to trigger remote event if you're using remote engine. It may not noticeable if the application didn't register any event listener and the application is not large or too complex.\n\n## Connect cable with port\nIt's more recommended to connect port with a port instead of creating a cable first. But if you have a Cable object obtained from somewhere that haven't been connected, you can also call `port.connectCable(cable)`.\n\n```js\nlet targetIface = instance.ref['targetIface']; // targetIface is the node ID\nlet { IInput, IOutput } = targetIface;\n\nIInput['PortName'].connectCable(cableFromSomewhere);\n```\n\nCable that was created from input port must be connected into output port and vice-versa, or it will immediately get deleted/disconnected.\n\n## Disconnect cable\nTo disconnect a cable, you can call `cable.disconnect()` function. Below is the example if you want to immediately disconnect a cable after being connected into a port:\n\n```js\n// This will help to keep the registration unique and avoid multiple similar listener unexpectedly been registered\nlet EventSlot = {slot: \"library-name\"};\n\nclass MyNode extends Blackprint.Node {\n\tstatic input = { PortName: Number }\n\tconstructor(){\n\t\t...\n\t\n\t\t// Triggered when a cable is connected\n\t\tlet { PortName } = this.ref.IInput;\n\t\tPortName.on('connect', EventSlot, function({ cable }){\n\t\t\tcable.disconnect();\n\t\t});\n\t}\n}\n```"},"Route":{"content":"## Routing nodes\nBy using route port you can prioritize or disable data flow from the connected cable. From the picture below, the data flow will only go through **Log** node on the top, while the bottom **Log** node will not get any data flow update.\n![0HKtI1Ekkp](https://user-images.githubusercontent.com/11073373/185189185-8296db5e-3b51-44d2-ae5b-7a29c1eba601.png)\n\nIt may not work if the data is updated not from inside of `update(){...}` function, for the example the **Input** node is actually listening the `<input>` box (HTML element) and directly assign value to **Value** port, because of that it will need to manually trigger `node.routes.routeOut()`. Below is an video example where the **Input** node is properly called the `routeOut` after modifying the **Value** port:\n\n<video src=\"https://user-images.githubusercontent.com/11073373/185191401-808e6df2-971f-40dd-b510-000ed859ee02.mp4\" controls></video>\n\n> A node can only have one `route out` on the right edge port (orange), and it can have multiple `route in` on the left\n\nThe route cable (orange dashed line) is used for controlling the data flow. By default any connected port will get updated every time the output port have a new value. But if the route cable was created (even not connected) and if some node already being connected with the output port but there are no route cable connected then the node will be inactive and turned into grey node. The grey node will not trigger it's `update()` function when there are any data update coming from the other output port as the data flow that trigger `update()` function will only be called depends on the connected route cable.\n\nThere are some condition that may make the unrouted node can still get updated:\n- The input node is using event listener that listening new value update from other output port\n- The node is self-update like using `setInterval` to obtain value from input node"}}},"Sketch Interface":{"content":"## Sketch Interface Registration\nThis registration is optional but required if you registered `Blackprint.registerInterface()` for your node. To register an interface into Blackprint Engine, your class need to extends from the class that you have registered with `Blackprint.registerInterface()` and then register it with `Blackprint.Sketch.registerInterface(namespace, class)`.\n\n> The namespace **must be** similar with the interface you have registered with `Blackprint.registerInterface()`.\n\n```js\n// CustomNodeIFace is a class we have made on \"Custom Nodes -> Interface\"\n// when we're registering with Blackprint.registerInterface()\n\nBlackprint.Sketch.registerInterface(\"BPIC/My/Custom/Node\",{\n\t// If you already write your HTML in .sf file extension, you can skip this field\n\thtml: `...see html template below...`,\n},\nclass extends CustomNodeIFace {\n    // 'constructor' here is optional, only for Blackprint.Node that was required to have\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.node === (/* Object reference from .registerNode() */);\n\t}\n});\n```\n\n> **Sketch Interface** is just like **Interface**, but with extended feature for handling user interface or HTML elements.\n\n### Lifecycle order\n1. `constructor()`: called on constructing new node object\n2. `imported()`: called after new node was constructed\n3. `init()`: called after all nodes have been constructed, all data imported, and cables has been connected\n4. Special lifecycle\n\t- `initClone()`: called when new node interface is created but for different HTML element\n\t- `hotReload()`: called before Blackprint begin hot reloading the node and iface\n\t- `hotReloadedHTML()`: called when was HTML changed/reloaded\n\t- `hotReloaded()`: called after hot reload complete, you may want to call init again from here\n\t- `destroyClone()`: called when node interface's clone was deleted\n5. `destroy()`: called on node deletion from instance\n\n> `hotReload` feature must use ScarletsFrame in Development Mode (hot reload feature need to be enabled manually). When hot reloading, the iface will have `this.hotReloading === true` and reset to false after hot reload was completed.\n\n### HTML template\nWhen registering interface for sketch instance, it's **required** to have a HTML template for your node. \n\n```js\nBlackprint.Sketch.registerInterface(\"BPIC/My/Custom/Node\", {\n\thtml: `...see html template below...`\n}, class extends Blackprint.Interfce {})\n```\n\nBelow is full basic template for a node, you're free to customize it to fit your needs and maybe remove some `<sf-template>` if you don't need it. You can add mustache template or apply two way binding on the template with the interface's property or data.\n```html\n<div class=\"node\" style=\"transform: translate({{ x }}px, {{ y }}px)\">\n  <sf-template path=\"Blackprint/nodes/template/routes.sf\"></sf-template>\n  <sf-template path=\"Blackprint/nodes/template/header.sf\"></sf-template>\n\n  <div class=\"content\">\n    <div class=\"left-port\">\n      <sf-template path=\"Blackprint/nodes/template/input-port.sf\"></sf-template>\n    </div>\n\n    <div class=\"right-port\">\n      <sf-template path=\"Blackprint/nodes/template/output-port.sf\"></sf-template>\n    </div>\n  </div>\n\n  <sf-template path=\"Blackprint/nodes/template/other.sf\"></sf-template>\n</div>\n```\n\nFor styling the node, you need to specify the tag name. The tag name is a lowercased letters of the interface's name and `/` symbol is converted into `-`.\n```scss\n// Element name is based on interface's namespace, BPIC/LibraryName/FeatureName/Template\nbpic-libraryname-featurename-template {\n  .node{\n\tfont-size: 16px;\n\t...\n  }\n}\n```\n\n### Initialize interface after creation\nScarletsFrame will call `init()` function once the node element was attached to DOM tree and you can begin initializing your HTML element.\n\n```js\nBlackprint.Sketch.registerInterface('BPIC/LibraryName/FeatureName/Template',\nclass IMyTemplate extends Context.IFace.MyTemplate {\n\t// Will run once the node element was attached to DOM tree\n\tinit(){\n\t\t// You can use `$el` to help manipulate your HTML or obtain element by using query selector\n\t\tthis.$el('.content').prepend(this.keepMe);\n\n\t\t// ====== Port Shortcut ======\n\t\tconst {\n\t\t\tIInput, IOutput, // Port interface\n\t\t\tInput, Output, // Port value\n\t\t} = this.ref;\n\t}\n});\n```\n\n### Handle removed interface\nScarletsFrame will call `destroy()` when the interface element is being removed.\n\n```js\nclass extends Blackprint.Interface {\n\tdestroy(){\n        // You can remove event listener from here and do some clean up\n\t}\n}\n```\n\n## Add event listener into a interface\nYou can also register an event that exist on **Interface** class. Below is some event addition for **Sketch Interface**:\n\n|Event Name|Event Object|Description|\n|---|---|---|\n|`cable.created`|`{ port: Port, cable: Cable }`|A cable was created from a port|\n|`port.hover`|`{ event: Event, port: Port }`|User hovered/focus on an port element|\n|`port.unhover`|`{ event: Event, port: Port }`|User leaving focus from an port element|\n|`port.menu`|<x-code2>{</x-t><x-t>instance: Engine \\| Sketch,</x-t><x-t>port: Port,</x-t><x-t>menu: Array,</x-t><x-t>event: Event,</x-t><x-t>preventDefault: Callback</x-t>}</x-code2>|User right clicked port element to open a menu|\n|`node.menu`|<x-code2>{<x-t>iface: Interface,</x-t><x-t>instance: Engine \\| Sketch,</x-t><x-t>menu: Array,</x-t><x-t>event: Event,</x-t><x-t>preventDefault: Callback</x-t>}</x-code2>|User right clicked the node's header to open a menu|\n\nBelow is one of example on how to register event on an interface:\n```js\n// Optional, but recommended to avoid re-register similar listener\nlet EventSlot = {slot: \"myLibraryName\"};\n\nclass extends Blackprint.Interface {\n\t// Interface event can be listened after the node was initialized.\n\tinit(){\n\t\tlet iface = this;\n\n\t\tiface.on('port.menu', function(data){\n\t\t\t// data.iface === iface\n\t\t\tlet menu = data.menu;\n\n\t\t\t// Add menu with callback\n\t\t\tmenu.push({\n\t\t\t\ttitle: \"With callback\",\n\t\t\t\tcallback(){...}\n\t\t\t});\n\n\t\t\t// Add menu with callback with the arguments\n\t\t\tmenu.push({\n\t\t\t\ttitle: \"Callback with arguments\",\n\t\t\t\targs: [1, 2],\n\t\t\t\tcallback(one, two){...}\n\t\t\t});\n\n\t\t\t// Add menu with callback with call context\n\t\t\tmenu.push({\n\t\t\t\ttitle: \"Callback with context\",\n\t\t\t\tcontext: data.port,\n\t\t\t\tcallback(one, two){\n\t\t\t\t\t// this === data.port\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Add menu and listen for mouse hover/unhover\n\t\t\tmenu.push({\n\t\t\t\ttitle: \"When mouse over the dropdown item\",\n\t\t\t\thover(){...},\n\t\t\t\tunhover(){...},\n\t\t\t});\n\n\t\t\t// Add menu inside of menu\n\t\t\tmenu.push({\n\t\t\t\ttitle: \"Deep level menu\",\n\t\t\t\tdeep: [{\n\t\t\t\t\ttitle: \"Level 1\",\n\t\t\t\t\tdeep: [{\n\t\t\t\t\t\ttitle: \"Level 2\",\n\t\t\t\t\t\tdeep:[{...}]\n\t\t\t\t\t}]\n\t\t\t\t}]\n\t\t\t});\n\t\t});\n\t}\n}\n```"}}},"Editor":{"content":"## What you can do inside Blackprint Editor\n- Use it as your environment for an experiment or prototyping project\n- Manage connection and data flow between nodes\n- Visualize data flow between cables\n- Save and load your data and use it on different environment\n- Develop new modules with help of `@blackprint/cli-tools`\n- Teach your friend who are new to programming\n\n> You may see some picture has different background from the original Editor. It's still the same editor but with a custom background that can be changed from the Editor's settings.\n\nLet's begin navigating to **Editor -> Tutorial** topic or **Engine -> Integration** if you want to run your exported Blackprint program on your project.","branch":{"API":{"content":"## Editor API\nBlackprint Editor does expose API from `window.BPEditor`, it's supposed to be used within nodes module. In the future if you're creating your own Editor you can just customize `window.BPEditor` with your custom functionality.\n\n### Usage\nBelow is usage example on how to use the API.\n\n#### Creating dialog\nThis Editor is using [SweetAlert](https://sweetalert2.github.io/#usage) for creating a dialog.\n\n```js\n// BPEditor.Dialog(...) == Swal.fire(...)\nBPEditor.Dialog({\n  title: 'Error!',\n  text: 'Do you want to continue',\n  icon: 'error',\n  confirmButtonText: 'Cool'\n});\n```\n\nIf you want to try the code above, you can open your browser's devtools and enter it into the console. You will see an \"error dialog\" on this editor as `BPEditor` is exposed globally. If you're using TypeScript, you can also use `window.BPEditor` to fix the typecheck.\n\n## Polyfill\nIf you're implementing your own editor from Blackprint Sketch, you will need to copy and paste code below to `<head></head>` before loading any nodes modules. You can also customize it if needed.\n\n```html\n<script src=\"//cdn.jsdelivr.net/npm/sweetalert2@11\"></script>\n<script>\n\twindow.BPEditor = {\n\t\tDialog: Swal.fire.bind(Swal),\n\t};\n</script>\n```"},"Side Panel":{"content":"## Left side panel\nOn the left side panel you can find list of Variables, Function, and Node. These list can be drag and dropped into the container to create a new nodes. From this editor you can easily create variable and function node by using `+` button, this editor also allows you to create a custom node by using a code editor. But if you're looking for how import nodes/modules for this editor, please go to **Editor -> Tutorial** instead.\n\nFor more information about the panel, please go to the menu:\n1. Variables **(Engine -> Internal Nodes -> Variables)**\n2. Functions **(Engine -> Internal Nodes -> Functions)**\n3. Events **(Engine -> Internal Nodes -> Events)**\n4. Groups **(See below -> Groups)**\n5. Nodes **(Custom Nodes)**\n\n## Groups\nThis section will be updated everytime you add/modify a group node in the instance. The group node can be manually created by adding `Decoration/Group/Default` node in the instance, or drag + right click to open the region menu for creating a group node like below:\n\n![electron_HQCQ6SUHmu](https://github.com/Blackprint/Blackprint/assets/11073373/3a30591a-d443-40a1-93e5-db3efc86a003)\n\nAfter that you will see the updated panel like below:\n\n![electron_DL4qXpvV9X](https://github.com/Blackprint/Blackprint/assets/11073373/c458f5b3-d5bb-4194-96f3-71584c28fd13)\n\nThe list item will become yellow if it's currently visible in your current viewport, and it will become normal when it was not visible anymore. If you want to immediately move to that group, you can just easily click the list.\n\n![electron_4QNoPD4o0v](https://github.com/Blackprint/Blackprint/assets/11073373/9d2badd5-983e-44d5-a55e-ca74c9b54fb5)\n\nThis group list will be automatically sorted, you can use numbered title when naming your groups to sort them up.\n\n## Right side panel\nThis panel is used for changing or adding an internal node data. You can also add ID or comments for your node and it can be exported as JSON. Registering a custom panel for your nodes is also possible when using Blackprint Sketch:\n\nThe component name **MUST** be started with `bppc-` and followed by node's namespace in lowercase letters\n`Blackprint.registerNode('Decoration/Group/Default', class Blackprint.Node { ... })`\n\n```js\n// We will add panel component for 'Decoration/Group/Default' node\nBlackprint.space.component('bppc-decoration-group-default', {\n\thtml: `...put the html here...`\n},\nclass extends sf.Model {\n\tconstructor(scope, iface){\n\t\tsuper(scope, iface);\n\n\t\t// Copy the iface, in case you need to access the node\n\t\tthis.iface = iface;\n\n\t\t// Copy the data by reference to current component context\n\t\t// to allow ScarletsFrame to bind to this data and create reactivity\n\t\tthis.data = iface.data;\n\t}\n});\n```\n\nBelow is example HTML that you can use as a template for the panel, the element name must be started with `bppc-`:\n```html\n<bppc-decoration-group-default>\n\t<div class=\"field title\">\n\t\t<span class=\"name\">Title:</span>\n\t\t<span class=\"help\"><i class=\"fas fa-question-circle\"></i></span>\n\t\t<textarea sf-bind=\"data.title\" placeholder=\"Add title here...\"></textarea>\n\t</div>\n\t<div class=\"field text-content\">\n\t\t<span class=\"name\">Text Content:</span>\n\t\t<textarea sf-bind=\"data.textContent\" placeholder=\"Add text content here...\"></textarea>\n\t</div>\n\t<div class=\"field color-pick-1\">\n\t\t<span class=\"name\">Background Color:</span>\n\t\t<input sf-bind=\"data.color\" placeholder=\"#b8b8ff\">\n\t</div>\n\t<div class=\"field color-pick-2\">\n\t\t<span class=\"name\">Font Color:</span>\n\t\t<input sf-bind=\"data.fontColor\" placeholder=\"black\">\n\t</div>\n</bppc-decoration-group-default>\n```\n\nAfter that, you can click the node and see the injected panel on the right side menu like:\n\n![Mo6pxVrMYS](https://github.com/Blackprint/Blackprint/assets/11073373/db2e6f43-120c-4510-af02-e9b17199e3da)\n\nYou can also see the implementation of [default group node](https://github.com/Blackprint/nodes/tree/master/nodes/Decoration/Group) to make this right side panel."},"Tutorial":{"content":"## Welcome to Tutorial List\nHere you can find some tutorial made for this Blackprint Editor. Some tutorial like using external nodes made by other developer or outside of this editor may not be covered here. You can click tutorial from the list below to begin:\n\n<sf-m name=\"docs-editor-tutorial\">\n\t<ul>\n\t\t<li sf-each=\"key, val in list\" @click=\"val()\">{{ key }}</li>\n\t</ul>\n</sf-m>\n\n<script>\nsf.model('docs-editor-tutorial', My => {\n\tMy.list = {};\n\n\tlet list = {\n\t\tasync \"Import module from NPM repository\"(){\n\t\t\tawait My.resetTutorial();\n\t\t\tTutorial.loadTutorial([{\n\t\t\t\tmessage:\"Let's go to sketch page by clicking this button\",\n\t\t\t\telement: '.welcome-text .content .item:nth-child(1)', onClick: 'next'\n\t\t\t}, {\n\t\t\t\tmessage:\"Open module list by clicking this\",\n\t\t\t\telement: '.header-menu [title=\"Loaded module\"]', onClick: 'next', delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"Click this to search module from NPM registry\",\n\t\t\t\telement: 'sf-m[name=\"module-url\"] [title=\"Search from NPM\"]', onClick: 'next', delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"You can type the library/module name here then press enter\",\n\t\t\t\telement: 'sf-m[name=\"npm-packages\"] .search input', delayShow: 700, onClick(){\n\t\t\t\t\tif(sf.model('npm-packages').list.length === 0)\n\t\t\t\t\t\tTutorial._domChanged($('sf-m[name=\"npm-packages\"] .list')[0], ()=> Tutorial.next());\n\t\t\t\t\telse Tutorial.next();\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tmessage:\"You can also click one of the module\\nThey are was contributed by community, but always becareful if you see something suspicious\",\n\t\t\t\telement: 'sf-m[name=\"npm-packages\"] .list', delayShow: 700, onClick(){\n\t\t\t\t\tTutorial._domChanged($('vw-modal')[0], ()=> Tutorial.next());\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tmessage:\"Usually one library may have separated module, click one that you need and it will be loaded and ready to be used. Greyed list means it already loaded to the editor.\",\n\t\t\t\telement: 'sf-m[name=\"npm-package-info\"] .list', delayShow: 700, onClick: 'next'\n\t\t\t}, {\n\t\t\t\tmessage:\"Alright let's open the module list again\",\n\t\t\t\telement: '.header-menu i.fa-boxes', delayShow: 700, onClick: 'next'\n\t\t\t}, {\n\t\t\t\tmessage:\"From this list you can see what modules you have loaded on this editor, click on empty space to continue tutorial\",\n\t\t\t\telement: 'sf-m[name=\"module-url\"] .content > div:nth-child(1)', delayShow: 700, onClick: 'next'\n\t\t\t}, {\n\t\t\t\tmessage:\"After the new module was loaded, the new nodes may appear on this list. You can drag and drop it to the sketch container to create nodes. Have fun!\",\n\t\t\t\telement: 'sketch-panel-left .node-list .tree-view', delayShow: 700, onClick(){\n\t\t\t\t\tTutorial.next();\n\t\t\t\t\tSmallNotif.add(\"You've completed the tutorial 🎉\", 'green');\n\t\t\t\t}\n\t\t\t}]);\n\t\t\tTutorial.next();\n\t\t},\n\t\tasync \"Import external Telegram module examples\"(){\n\t\t\tawait Swal.fire({\n\t\t\t\ttitle: 'Preparation',\n\t\t\t\ticon: 'info',\n\t\t\t\thtml:'First.. Right click and copy <a style=\"color: lightblue\" href=\"https://github.com/Blackprint/nodes-telegram\" target=\"_blank\">this</a> repository URL',\n\t\t\t\tshowCloseButton: false,\n\t\t\t\tshowCancelButton: false,\n\t\t\t});\n\t\t\t\n\t\t\tawait My.resetTutorial();\n\t\t\tTutorial.loadTutorial([{\n\t\t\t\tmessage:\"Let's go to sketch page by clicking this button\",\n\t\t\t\telement: '.welcome-text .content .item:nth-child(1)', onClick: 'next'\n\t\t\t}, {\n\t\t\t\tmessage:\"Open module example list by clicking this\",\n\t\t\t\telement: '.header-menu [title=\"Module examples\"]', onClick: 'next', delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"Paste the repository URL here and press enter\",\n\t\t\t\telement: 'sf-m[name=\"module-example-list\"] input', onClick(){\n\t\t\t\t\tTutorial._domChanged($('vw-modal')[0], ()=> Tutorial.next());\n\t\t\t\t}, delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"Here you may find the example list for the module, click it to begin importing\",\n\t\t\t\telement: 'sf-m[name=\"module-example-list-deep\"] .list', onClick(){\n\t\t\t\t\tTutorial._domChanged($('vw-modal')[0], ()=> Tutorial.next());\n\t\t\t\t}, delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"For security and debugging purpose, this window will appear before begin importing required modules and the nodes. If you're confident with it, let's press the Import Sketch button.\",\n\t\t\t\telement: 'sf-m[name=\"sketch-importer\"]', onClick(){\n\t\t\t\t\tTutorial._domChanged($('sf-space[blackprint] sf-m[name=\"cables\"]')[0], ()=> Tutorial.next());\n\t\t\t\t}, delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"After the example was loaded, find and read the notes. The example may have a tutorial to begin with.\",\n\t\t\t\telement: 'bpic-decoration-text-notes > div', onClick: 'next', delayShow: 1000\n\t\t\t}, {\n\t\t\t\tmessage:\"To edit your environment variables for your editor, you can click here:\",\n\t\t\t\telement: 'sketch-panel-left .variable-list > .tree-item:nth-child(2) > .button', onClick: 'next', delayShow: 700\n\t\t\t}, {\n\t\t\t\tmessage:\"Some example may require you to fill this variables, just follow the notes if it exist. Have fun!\",\n\t\t\t\telement: 'sf-m[name=\"environment-variables\"] .content', delayShow: 700, onClick(){\n\t\t\t\t\tTutorial.next();\n\t\t\t\t\tSmallNotif.add(\"You've completed the tutorial 🎉\", 'green');\n\t\t\t\t}\n\t\t\t}]);\n\t\t\tTutorial.next();\n\t\t}\n\t};\n\n\tMy.init = My.hotReloaded = function(){ My.list = list }\n\tMy.resetTutorial = async function(){\n\t\tModal.hide();\n\t\tawait views.goto('/');\n\t\tTutorial.clearTutorial();\n\t\tawait new Promise(resolve => setTimeout(resolve, 300));\n\t}\n});\n</script>\n\n> More tutorial will be added in the future 😉"}}},"Engine":{"content":"## Load the engine and modules\n<docs-md-tabs>\n<div class=\"tabs\"><div sf-each=\"x in tabs\">{{ x }}</div></div>\n\n<div tab=\"Browser\">\n\nIn the browser you can easily import the from CDN, and you will have `Blackprint` object on the `window` context.\n\n```html\n<!-- Put this in <head> -->\n<script src=\"https://cdn.jsdelivr.net/npm/@blackprint/engine@0.10\" crossorigin=\"anonymous\"></script>\n\n<!-- [Optional] Load required modules -->\n<!-- If you didn't do this, Blackprint Engine may load from module list that specified on the exported JSON -->\n<script src=\"https://cdn.jsdelivr.net/npm/...[the required module URL]...\" crossorigin=\"anonymous\"></script>\n```\n\n</div><div tab=\"Node.js\">\n\n#### Installing the engine\nYou can use `npm`, `pnpm`, or `yarn` when installing packages. But it's recommended to use `pnpm` to save disk space.\n\n```sh\n$ pnpm i @blackprint/engine\n```\n\n#### Load required module\nIn this example we will name the file as `init.js`\n\n```js\n// Initialize the engine first\nlet Blackprint = require(\"@blackprint/engine\");\n\n// [Optional] Blackprint can also load from module list specified on the exported JSON\nrequire(\"...[the required module URL]...\");\n```\n\n#### Run your application\nIf you don't load any modules by URL and prefer to manually `require` the modules, you can use this command:\n\n```sh\n$ node init.js\n```\n\n---\n\nIf you want to load modules by URL, you need to use a https loader:\n> You must use `.mjs` as the entry point's file extension\n\n```sh\n$ node --no-warnings --loader ./node_modules/@blackprint/engine/es6-https-loader.mjs ./init.mjs\n```\n\n</div><div tab=\"Deno\">\n\n#### Load the engine from CDN\nIn this example we will name the file as `init.mjs`\n\n```js\n// Initialize the engine first\nimport Blackprint from 'https://cdn.skypack.dev/@blackprint/engine@0.10';\n```\n\n#### Run your application\nBlackprint for Deno will load modules from URL, you just need to make sure the exported JSON does contain the required module list.\n\n```sh\n$ deno run --allow-net ./init.mjs\n```\n\n</div><div tab=\"PHP\">\n\n#### Installing the engine package\n```sh\n$ composer install blackprint/engine\n```\n\nAfter that you can just import with autoload, you also need to install another required nodes module manually.\n\n```php\nrequire_once('vendor/autoload.php');\n```\n\n</div><div tab=\"Golang\">\n\n#### Installing the engine package\n```sh\n$ go get https://github.com/Blackprint/engine-go\n```\n\n#### Write your entry point file\n\n```go\npackage main\n\nimport (\n\tBlackprint \"github.com/blackprint/engine-go/blackprint\"\n\t\"github.com/blackprint/engine-go/engine\"\n\t\"github.com/blackprint/engine-go/types\"\n)\n\nfunc main() {\n\t// ...\n}\n```\n\n</div></docs-md-tabs>\n\n## Create Engine Instance\n```js\n// If you load from CDN, \"Blackprint\" is registered in window object\nimport Blackprint from '@blackprint/engine';\n\n// Only allow import module from cdn.jsdelivr.net, the first parameter can also be an array\nBlackprint.allowModuleOrigin('cdn.jsdelivr.net');\n\n// If you're running on Node.js and don't want to load modules from URL\n// you need to manually imports the modules before calling 'createNode' or 'importJSON'\n\n// Create Blackprint Engine instance\nvar instance = new Blackprint.Engine();\n```\n\n### Create node in an instance\n```js\nvar iface = instance.createNode('MyModule/Math/Multiply', {/* optional options */});\n\n/**\n * Create a node from a namespace\n * @param namespace Node namespace\n * @param options additional options\n */\ncreateNode(namespace: string, options?: {\n\tdata?: object, // You can access this data in a class with `imported(data){...}`\n\tx?: number, // Node X position\n\ty?: number, // Node Y position\n\tid?: number, // Node ID\n}): Interface;\n```\n\n### Import nodes from JSON\nIf you have exported Blackprint into JSON, then you can easily import it like below:\n```js\ninstance.importJSON(/* JSON || Object */);\n\n/**\n * Import nodes structure and connection from JSON\n * @param json JSON data\n * @param options additional options for importing JSON data\n */\nimportJSON(json: string | object, options?: {\n\t/** Set this to false if you want to clear current instance before importing */\n\tappendMode?: Boolean,\n\t/** Skip importing environment data if exist on the JSON */\n\tnoEnv?: Boolean,\n\t/** Skip importing module URL (in case if you already imported the nodes from somewhere) */\n\tnoModuleJS?: Boolean,\n}): Promise<Array<Interface>>;\n```\n\n### Delete node from an instance\n```js\n// Delete a single node\ninstance.deleteNode(myIfaceObject);\n// instance.deleteNode(iface: Interface): void;\n\n// To delete all nodes at once\ninstance.clearNodes();\n```\n\n## Add event listener to the instance\nThese event can also be used for **Sketch Instance**.\n\n|Event Name|Event Object|Description|\n|---|---|---|\n|`node.id.changed`|`{ iface: Interface, old: String, now: String }`|Node ID was added/changed/removed|\n|`cable.disconnect`|`{ port: Port, target?: Port, cable: Cable }`|A cable was disconnected or deleted|\n|`cable.connect`|`{ port: Port, target: Port, cable: Cable }`|A cable was connected between two port|\n|`json.imported`|`{ appendMode: Boolean, nodes: Array, raw: String }`|JSON was imported into the instance|\n|`cable.created`|`{ port: Port, cable: Cable }`|A cable was created|\n|`cable.deleted`|`{ cable: Cable }`|A cable was deleted|\n|`node.delete`|`{ iface: Interface }`|A node is being deleted|\n|`node.deleted`|`{ iface: Interface }`|A node was deleted|\n|`node.created`|`{ iface: Interface }`|A node was created|\n|`error`|`{ type: String, data: Object }`|An error happened on the instance|\n|`event.field.created`|`{ name: String, namespace: String }`|New event data field was created|\n|`event.field.renamed`|`{ old: String, now: String, namespace: String }`|An event data field was renamed|\n|`event.field.deleted`|`{ name: String, namespace: String }`|An event data field was deleted|\n|`variable.new`|<x-code2>{<x-t>scope: VarScope,</x-t><x-t>id: String,</x-t><x-t>reference?: BPVariable,</x-t><x-t>bpFunction?: BPFunction,</x-t>}</x-code2>|New variable was created|\n|`variable.renamed`|<x-code2>{<x-t>old: String, now: String,</x-t><x-t>scope: VarScope,</x-t><x-t>reference?: BPVariable,</x-t><x-t>bpFunction?: BPFunction,</x-t>}</x-code2>|A variable was renamed|\n|`variable.deleted`|<x-code2>{<x-t>id: String,</x-t><x-t>scope: VarScope,</x-t><x-t>bpFunction?: BPFunction,</x-t>}</x-code2>|A variable was deleted|\n|`function.new`|`{ reference: BPFunction }`|A function template was created|\n|`function.renamed`|`{ old: String, now: String, reference: BPFunction }`|A function template was renamed|\n|`function.deleted`|`{ reference: BPFunction, id: String }`|A function template was deleted|\n|`event.new`|`{ reference: InstanceEvent }`|An event namespace was created|\n|`event.renamed`|`{ old: String, now: String, reference: InstanceEvent }`|An event namespace was renamed|\n|`event.deleted`|`{ reference: InstanceEvent }`|An event namespace was deleted|\n|`execution.paused`|<x-code2>{<x-t>afterNode?: Node<NodeStaticProps>,</x-t><x-t>beforeNode?: Node<NodeStaticProps>,</x-t><x-t>cable?: Cable,</x-t><x-t>cables?: Cable[],</x-t><x-t>triggerSource: Number,</x-t>}</x-code2>|The instance have been paused|\n|`execution.terminated`|`{ reason: String, iface: Interface }`|The instance data flow got terminated|\n|`function.port.renamed`|<x-code2>{<x-t>which: PortWhich,</x-t><x-t>old: String,</x-t><x-t>now: String,</x-t><x-t>reference: BPFunction,</x-t>}</x-code2>|A function node's port get renamed|\n|`function.port.deleted`|<x-code2>{<x-t>which: PortWhich,</x-t><x-t>name: String,</x-t><x-t>reference: BPFunction,</x-t>}</x-code2>|A function node's port get deleted|\n|`execution.terminated`|`{ reason: String, iface: Interface }`|The instance data flow got terminated|\n\nBelow is an example on how to register event on the instance:\n```js\nlet EventSlot = {slot: \"myLibraryName\"}; // Optional, but recommended to avoid re-register similar listener\nlet instance = new Blackprint.Engine();\n\ninstance.on('node.id.changed', EventSlot, function(event){\n\tconsole.log(`Node ID from \"${event.iface.title}\" was changed from \"${event.from}\" into \"${event.to}\"`);\n});\n```\n\n### Global event\n|Event Name|Event Object|Description|\n|---|---|---|\n|`module.added`|`{ url: String }`|New module registration|\n|`module.update`|`null`|A registered module was updated|\n|`module.delete`|`{ url: String }`|Module registration was deleted|\n|`environment.imported`|`null`|Imported new environment variables|\n|`environment.added`|`{ key: String, value: String }`|New environment variable was added|\n|`environment.changed`|`{ key: String, value: String }`|Environment variable data was changed|\n|`environment.renamed`|`{ old: String, now: String }`|Environment variable data was renamed|\n|`environment.deleted`|`{ key: String }`|Environment variable data was deleted|\n\nBelow is an example on how to register event into Blackprint:\n```js\nBlackprint.on('environment.renamed', EventSlot, function(event){\n\tconsole.log(`An environment key was changed from \"${event.old}\" into \"${event.now}\"`);\n});\n```","branch":{"Integration":{"content":"## Blackprint Engine Integration\nWhen you want to export and integrate Blackprint into your project (without sketch container or user interface), you only need to import Blackprint Engine and the required modules to your project.\n\n## Integrate with frontend framework\nThe engine perform nicely with some framework like Vue, and ScarletsFrame. You can easily use two-way data binding for the node's ports with them. But if your project doesn't use these framework, you can still use listen to port's event and change the value manually from the port itself.\n\n## Integrate with the event listener\nBefore you want to integrate, you need to create new Engine instance and import your JSON into that instance. If you haven't loaded any modules to your project or want to import module from URL, you need to allow import from origin as it default to disabled.\n\n```js\n// Only allow import module from cdn.jsdelivr.net, you can also change this into array\nBlackprint.allowModuleOrigin('cdn.jsdelivr.net');\n\n// Create new engine instance\nvar instance = new Blackprint.Engine();\nawait instance.importJSON(YOUR_JSON_TEXT);\n```\n\nMake sure you have add ID to your nodes, to make it easier to obtain its object reference. In the Blackprint Editor you can right click the node's header and add ID. For the example, the node below does have `hello` ID and have a label icon on the header.\n\n![CScawXMWdJ](https://user-images.githubusercontent.com/11073373/184813410-0b5dab4c-ad09-48e2-a3ec-cb5a35efa880.png)\n\nFrom the instance, you can obtain the node by using code below:\n```js\nlet { hello } = instance.ref;\n```\n\nYou can also obtain the port `Result`'s value with `hello.Output.Result`. You can also call or obtain from `Input` port, but you can't change it's value directly. In that case, you may need to create a `Public Variable` or using `new Blackprint.OutputPort()`.\n\nFor example, to call the `Exec` port you can do it like below:\n```js\nlet { hello } = instance.ref;\nhello.Input.Exec();\n\n// For listening the call event for port Exec\nhello.IInput.Exec.on('call', function(){ ... });\n\n// To obtain value from port A\nlet valA = hello.Input.A;\n```\n\nIf you want to modify the input port's value, you must connect it to other output port:\n```js\nlet { hello } = instance.ref;\n\n// Create output port virtually\nlet MyOutput = new Blackprint.OutputPort(Number); // Type Data: Number\nMyOutput.value = 123; // Assign value for this port\n\n// Connect our virtual port to the node (`A` port)\n// `IInput` is input port's interface\nMyOutput.connectPort(hello.IInput.A); \n```\n\nYou can also listen for value changes for the `Result`'s port, but these listener must be registered before any event occurs.\n```js\nlet { hello } = instance.ref;\n\n// IOutput = output port's interface\nhello.IOutput['Result'].on('value', function(ev){\n  let portValue = ev.port.value;\n\n  // ev.cable.value; // 'ev.cable' and 'ev.target' only exist for Input port\n})\n```\n\nFor further information please go to **Custom Nodes** documentation, the engine is designed to be similar for each programming language. It wont be difficult if you already familiar with the documentation for JavaScript.\n\nBelow is an example that you can try to help you getting familiar with the API:\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Blackprint Engine + Event Listener\" src=\"https://codepen.io/stefansarya/embed/dymQpdq?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/stefansarya/pen/dymQpdq\">\n  Blackprint Engine + Event Listener</a> by StefansArya (<a href=\"https://codepen.io/stefansarya\">@stefansarya</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>","branch":{"React":{"content":"## Frontend Integration\nReact didn't seems to have two-way data binding feature that compatible with Blackprint Engine. You will need to manually change the port value and listen for it's event, and also refresh React's state.\n\n## Example\n<center>\n\nImage below is the visualization for the JSON on Blackprint Sketch.\n![Y3Lf93U14X](https://user-images.githubusercontent.com/11073373/184805845-ba6b13b4-fbc0-474c-b894-b6bcb40671e9.png)\n\n</center>\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Blackprint Engine + React\" src=\"https://codepen.io/stefansarya/embed/abYQZeJ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/stefansarya/pen/abYQZeJ\">\n  Untitled</a> by StefansArya (<a href=\"https://codepen.io/stefansarya\">@stefansarya</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\nBelow is the JavaScript for the example above\n```jsx\n// Only allow module from cdn.jsdelivr.net (Change this into array if needed)\nBlackprint.allowModuleOrigin('cdn.jsdelivr.net');\n\n// You can copy paste this to Blackprint Editor\nlet json_text = `{\"instance\":{\"Console/Log\":[{\"i\":0,\"x\":556,\"y\":109,\"z\":0,\"id\":\"logger\"}],\"Input/UI/SliderBox\":[{\"i\":1,\"x\":86,\"y\":154,\"z\":1,\"id\":\"slider1\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"A\"}]}},{\"i\":4,\"x\":86,\"y\":193,\"z\":2,\"id\":\"slider2\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"B\"}]}}],\"Example/Math/Multiply\":[{\"i\":2,\"x\":326,\"y\":90,\"z\":3,\"id\":\"multiply\",\"output\":{\"Result\":[{\"i\":0,\"name\":\"Any\"}]}}],\"Example/Button/Simple\":[{\"i\":3,\"x\":49,\"y\":55,\"z\":4,\"output\":{\"Clicked\":[{\"i\":2,\"name\":\"Exec\"}]}}]},\"moduleJS\":[\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-console.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-input.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-example.mjs\"]}`;\n\n// Initialize our component first\nclass MyReact extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    // Bring the nodes reference to our component scope\n    let nodes = this.nodes = props.instance.ref;\n\n    // Calling port => Multiply.Exec for activation\n    nodes['multiply'].Input.Exec();\n\n\t// Listen to React's input element's change event\n    this.onSlider1 = (ev) => nodes['slider1'].Output[0] = +ev.target.value;\n    this.onSlider2 = (ev) => nodes['slider2'].Output[0] = +ev.target.value;\n\n    let onResultChange = ()=> this.setState({});\n\n    // Refresh React's state everytime port value\n    // from Multiply.Result port was updated\n    nodes['multiply'].IOutput.Result.on('value', onResultChange);\n  }\n\n  render() {\n    return (\n      <div>\n        The first slider => Port \"0\":<br/>\n        <input value={this.nodes['slider1'].Output[0]} onChange={this.onSlider1} type=\"number\"/>\n\n        The second slider => Port \"0\":<br/>\n        <input value={this.nodes['slider2'].Output[0]} onChange={this.onSlider2} type=\"number\"/>\n\n        Node \"Multiply\" => Port \"Result\":<br/>\n        <span>{this.nodes['multiply'].Output.Result}</span>\n      </div>\n    );\n  }\n}\n\n// Create new engine instance\nvar instance = new Blackprint.Engine();\n\n// ===== Load from JSON =====\n// Import nodes from URL and wait until imported\ninstance.importJSON(json_text).then(function(){\n  // Put the React element into container after the JSON was imported\n  let container = document.getElementById('container');\n  let root = ReactDOM.createRoot(container);\n\n  root.render(<MyReact instance={instance}/>);\n});\n```"},"ScarletsFrame":{"content":"## Frontend Integration\nWith ScarletsFrame you can easily bind the ports with your views/template.\n\n\n## Example\n<center>\n\nImage below is the visualization for the JSON on Blackprint Sketch.\n![Y3Lf93U14X](https://user-images.githubusercontent.com/11073373/184805845-ba6b13b4-fbc0-474c-b894-b6bcb40671e9.png)\n\n</center>\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Blackprint Engine + ScarletsFrame\" src=\"https://codepen.io/stefansarya/embed/YzaRGEJ?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/stefansarya/pen/YzaRGEJ\">\n  Blackprint Engine + ScarletsFrame</a> by StefansArya (<a href=\"https://codepen.io/stefansarya\">@stefansarya</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\nBelow is the JavaScript for the example above\n```js\n// Only allow module from cdn.jsdelivr.net\nBlackprint.allowModuleOrigin('cdn.jsdelivr.net');\n\n// You can copy paste this to Blackprint Editor\nlet json_text = `{\"instance\":{\"Console/Log\":[{\"i\":0,\"x\":556,\"y\":109,\"z\":0,\"id\":\"logger\"}],\"Input/UI/SliderBox\":[{\"i\":1,\"x\":86,\"y\":154,\"z\":1,\"id\":\"slider1\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"A\"}]}},{\"i\":4,\"x\":86,\"y\":193,\"z\":2,\"id\":\"slider2\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"B\"}]}}],\"Example/Math/Multiply\":[{\"i\":2,\"x\":326,\"y\":90,\"z\":3,\"id\":\"multiply\",\"output\":{\"Result\":[{\"i\":0,\"name\":\"Any\"}]}}],\"Example/Button/Simple\":[{\"i\":3,\"x\":49,\"y\":55,\"z\":4,\"output\":{\"Clicked\":[{\"i\":2,\"name\":\"Exec\"}]}}]},\"moduleJS\":[\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-console.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-input.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-example.mjs\"]}`;\n\n// Create new engine instance\nvar instance = new Blackprint.Engine();\n\n// ===== Load from JSON =====\n// Import nodes from URL and wait until imported\ninstance.importJSON(json_text).then(function(){\n  // We need to import the JSON first before obtaining the node's ports\n  sf.component('my-component', function(My){\n    // Bring the nodes references to component scope\n    My.nodes = instance.ref;\n\n    // Calling port => Multiply.Exec for activation\n    My.nodes['multiply'].Input.Exec();\n  });\n});\n```\n\nIn the HTML template, you can obtain the port's value with `NodeID.Output.PortName`. Because the slider is using number as its port name, we can obtain it using `NodeID.Output[0]`. You can also call or obtain from `Input` port, but you can't change it's value directly. In that case, you may need to create a `Public Variable` or using `new Blackprint.OutputPort()`.\n```html\n<my-component>\n\tThe first slider => Port \"0\":<br>\n\t<input sf-bind=\"nodes['slider1'].Output[0]\" type=\"number\">\n\n\tThe second slider => Port \"0\":<br>\n\t<input sf-bind=\"nodes['slider2'].Output[0]\" type=\"number\">\n\n\tNode \"Multiply\" => Port \"Result\":<br>\n\t<span id=\"hello\">\n\t\t{{ nodes['multiply'].Output.Result }}\n\t</span>\n</my-component>\n```"},"Vue":{"content":"## Frontend Integration\nWith Vue you can easily bind the ports with your views/template, but you still need input listener to change the port's value.\n\n\n## Example\n<center>\n\nImage below is the visualization for the JSON on Blackprint Sketch.\n![Y3Lf93U14X](https://user-images.githubusercontent.com/11073373/184805845-ba6b13b4-fbc0-474c-b894-b6bcb40671e9.png)\n\n</center>\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Blackprint Engine + Vue\" src=\"https://codepen.io/stefansarya/embed/YzaRGwv?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/stefansarya/pen/YzaRGwv\">\n  Blackprint Engine + Vue</a> by StefansArya (<a href=\"https://codepen.io/stefansarya\">@stefansarya</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\nBelow is the JavaScript for the example above\n```js\n// Only allow module from cdn.jsdelivr.net\nBlackprint.allowModuleOrigin('cdn.jsdelivr.net');\n\n// You can copy paste this to Blackprint Editor\nlet json_text = `{\"instance\":{\"Console/Log\":[{\"i\":0,\"x\":556,\"y\":109,\"z\":0,\"id\":\"logger\"}],\"Input/UI/SliderBox\":[{\"i\":1,\"x\":86,\"y\":154,\"z\":1,\"id\":\"slider1\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"A\"}]}},{\"i\":4,\"x\":86,\"y\":193,\"z\":2,\"id\":\"slider2\",\"data\":{\"0\":{\"value\":2,\"min\":-100,\"max\":100,\"step\":0.1}},\"output\":{\"0\":[{\"i\":2,\"name\":\"B\"}]}}],\"Example/Math/Multiply\":[{\"i\":2,\"x\":326,\"y\":90,\"z\":3,\"id\":\"multiply\",\"output\":{\"Result\":[{\"i\":0,\"name\":\"Any\"}]}}],\"Example/Button/Simple\":[{\"i\":3,\"x\":49,\"y\":55,\"z\":4,\"output\":{\"Clicked\":[{\"i\":2,\"name\":\"Exec\"}]}}]},\"moduleJS\":[\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-console.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-input.mjs\",\"https://cdn.jsdelivr.net/npm/@blackprint/nodes@0.9/dist/nodes-example.mjs\"]}`;\n\n// Create new engine instance\nvar instance = new Blackprint.Engine();\n\n// ===== Load from JSON =====\n// Import nodes from URL and wait until imported\ninstance.importJSON(json_text).then(function(){\n  // We need to import the JSON first before obtaining the node's ports\n  Vue.createApp({\n    data() {\n\t  let { multiply } = instance.ref;\n\n      // Calling port => Multiply.Exec for activation\n      multiply.Input.Exec();\n\n      // Vue 3 is using Proxy for their reactivity\n      // You may need to use event listener and update Vue element's value manually like:\n      multiply.IOutput.Result.on('value', ({ port })=> this.myProp = port.value);\n\n      // Put the ports reference to this component scope\n      return instance.ref;\n    }\n  }).mount('#v-model-basic');\n});\n```\n\nIn the Vue's template, you can obtain the port's value with `NodeID.Output.PortName`. Because the slider is using number as its port name, we can obtain it using `NodeID.Output[0]`. You can also call or obtain from `Input` port, but you can't change it's value directly. In that case, you may need to create a `Public Variable` or using `new Blackprint.OutputPort()`.\n```html\n<div id=\"v-model-basic\">\n\tThe first slider => Port \"0\":<br>\n\t<input\n\t\ttype=\"number\"\n\t\t:value=\"slider1.Output[0]\"\n\t\t@input=\"slider1.Output[0] = +$event.target.value\">\n\n\tThe second slider => Port \"0\":<br>\n\t<input\n\t\ttype=\"number\"\n\t\t:value=\"slider2.Output[0]\"\n\t\t@input=\"slider2.Output[0] = +$event.target.value\">\n\n\tNode \"Multiply\" => Port \"Result\":<br>\n\t<span id=\"hello\">\n\t\t{{ multiply.Output.Result }}\n\t</span>\n</div>\n```"}}},"Internal Nodes":{"content":"## Internal Nodes\nBlackprint Engine doesn't internally have nodes like math or loops as it's can be distributed and maintained separately as an external nodes. But internally the engine has internal nodes as a helper for the engine instance:\n\n1. Event\n2. Function\n3. Variable","branch":{"Event":{"content":"## Event Node\nEvent node can be used for listening your custom event in the instance and emitting event. Everytime the event is emitted, all node that listening to the event will also updating. It's also useful if you want to emit external event into your Blackprint instance, you can also listen event from the instance and listen it externally.\n\nEvent node should be used as a main entry point of your program. This node is also required if you want to generate native code from your Blackprint instance for the target language.\n\n### Register instance event node using script\nThe exported instance (.json) may already include information for creating event internally. But it doesn't include information about the data type of the schema, the data type will be set as `Any` for each keys. If sometime it cause a problem, you can also register it with a program before importing the instance (.json).\n\n```js\n// 'instance' is Blackprint.Engine or Blackprint.Sketch\ninstance.events.createEvent('MyApp/MyEvent', {\n\tschema: {\n\t\t// FieldName: DataType\n\t\tMyNumber: Number,\n\t}\n});\n\n// instance.importJSON(...)\n```\n\nRegistering externally may also be useful if you want to create empty instance but with your own prepared custom event data's schema in the instance itself.\n\nFor example the code above will create event with namespace `MyApp/MyEvent`. When you create the node to the sketch, you will see a node that have red header. The `schema` fields that you five into `.createEvent(namespace, { schema })` will become the output port of this node.\n\n![electron_wBpqJbRiDx](https://github.com/Blackprint/Blackprint/assets/11073373/311eadf4-c399-493c-a153-d35828141afb)\n\n![electron_dg6C6XnBrp](https://github.com/Blackprint/Blackprint/assets/11073373/628e9ed1-f567-4413-8ea1-85caca12f506)\n\n### Emit to instance event using script\nIn Blackprint, you can use `Event Emitter` node to emit the event data to the instance. The event data will be forwarded into every event listener of the instance. But you can also emit the event by using script to the instance like below:\n\n```js\n// 'instance' is Blackprint.Engine or Blackprint.Sketch\ninstance.events.emit('MyApp/MyEvent', {\n\t// FieldName: Value\n\tMyNumber: 123,\n});\n```\n\n### Listen to instance event using script\nIn Blackprint, you can use `Event Listener` node to listen the event data to the instance. If you change the `Limit` port's input you will also need to call `Reset` port to trigger the node to reset, and use `Off` port to deactivate the node's event listener. But you can also listen the event by using script to the instance like below:\n\n```js\n// 'instance' is Blackprint.Engine or Blackprint.Sketch\ninstance.events.listen('MyApp/MyEvent', function(data) {\n\tconsole.log(\"Got MyNumber:\", data.MyNumber)\n});\n```\n"},"Function":{"content":"## Function Node\nFunction node can be used for grouping your nodes into a single nodes and also be used as a function. Each created node is a different Blackprint instance but does share the function/variable of the main instance. The function node also have different variable node feature:\n\n1. **Public variable**: shared with other function node and the instance outside of the function\n2. **Shared variable**: shared with other function node but not shared with the instance\n3. **Private variable**: only can be accessed inside each function, and each function with the same variable name will have different value"},"Variable":{"content":"## Variable Node\nVariable node can be used for storing output value from a node. Everytime this node set new value, every node that stands as a getter node will update their value. Sometime you may also don't want one of the getter node is triggering some nodes connected to it, to fix it you need to create a output route cable that doesn't not connected to any node for the getter node.\n\n### Register variable node externally\nThe exported instance (.json) may already include information for creating variable internally. But it doesn't include information about the data type, so the data will be set after it's initialized. If sometime it cause a problem, you can also register it with a program before importing the instance (.json).\n\n```js\n// 'instance' is Blackprint.Engine or Blackprint.Sketch\nlet myVar = instance.createVariable('MyApp/MyNumber');\nmyVar.type = Number;\nmyVar.value = 12345;\n\n// instance.importJSON(...)\n```\n\nRegistering externally may also be useful if you want to create empty instance but with your own prepared custom variable in the instance itself."}}}}},"FAQ":{"content":"## Frequency Asked Question\n\n### Can I use Blackprint for commercial software?\nYes, you're free to use **Blackprint Engine** and **Sketch** for your commercial software. But for the **Blackprint Editor** I didn't recommend you to use it as a base for your final product as it has rapid changes, and the code base will changes randomly except the exposed API.\n\n### Why is this project is free?\nOriginally the author of Blackprint is a game developer and a freelancer, I already realize that I may not be able to full time working on all of projects that I have. I will always check and give support for people who have an issue when using my libraries or project that I have made. Blackprint will stay using MIT License, free to use for your company or commercial project and hoping you would contribute back (module/nodes/bug fixes/support) for Blackprint.\n\n### When version 1.0 will be released?\nCurrently Blackprint can be considered still in beta version, I already done most of the planned engine feature. But I still looking for some bug fixes + improvement and trying to create larger project using Blackprint. If the engine doesn't have any breaking changes for more than one year, then it may be ready to be released as `v1.0` and will follow semantic versioning.\n\nIn this beta version breaking changes may happen on incremental of `v0.x.0`, new features and bug fixes may happen on `v0.0.x`. If the API is already being used and documented, the breaking changes will also be documented on `CHANGELOG.md`.\n\n### This is looks similar with UE Blueprint, did you copy their code?\nNo! Blackprint is inspired with UE's Blueprint but the initial development of Blackprint Engine and Sketch is made with JavaScript, and there's no code that has been copy and pasted or adapted from their code. The author of Blackprint also have never used UE Blueprint when developing Blackprint in 2020. It visually may looks similar with UE's Blueprint because of the node's theme (user interface design), you can also customize the theme with HTML and CSS if you prefer other design/theme.\n\n### Do you have any plan to make the code base more modular using ES Modules?\nYes I have a plan. But feel free to make it modular or use TypeScript, I will happily to merge your Pull Request if it's working. Currently some template like `.sf` extension couldn't be compiled with Vite or Webpack, we need to make a custom plugin to make it possible and currently I only have a custom compiler for it.\n\n### Can you develop Blackprint Sketch with Vue/React as the code base instead?\nI would like to, but I think it will a bit more complex and also I don't have time for working on it. Even I already made it, I may not be able to maintain everything by myself because I also have to work on something else.\n\nBut I already provide an integration example for the Blackprint Engine, and you can easily integrate the engine with Vue (with reactivity) / React (with listener) to rewrite the Blackprint Sketch that was written using ScarletsFrame (with reactivity).\n\n---\n\nWe expect some constructive feedback and healty discussion to help Blackprint grow more better."},"Getting Started":{"content":"## Welcome to Getting Started!\nLet's begin our journey for learning Blackprint by getting familiar with the editor first. This editor also have some tutorial to help you learn on how to do something.\n\nIn this Blackprint Editor your first journey is importing existing module that has been contributed by community into NPM registry. If you're importing an example, it will also automatically load it's required modules into the editor.\n- In case if you didn't find any suitable nodes for your requirement, you also can create your custom module for your project and contribute it into open source community if you want to **(Custom Nodes)**.\n- If you want to deploy your project into browserless environment, you can export the diagrams into JSON and import it with Blackprint Engine **(Engine - Installation)**.\n- You can also integrate Blackprint Engine with your React/Vue project by binding the input/output port for the nodes **(Engine - Integration)**.\n\nWell, let's navigate to another documentation. This documentation covers on how to:\n- Using the Blackprint Editor **(Editor - Tutorial)**\n- Embedding sketch container to your project **(Sketch - Installation)**\n- Use Blackprint Engine to run your exported diagrams in different environments **(Engine - Installation)**\n- Creating custom nodes or modules from a template **(Custom Nodes)**"},"Home":{"content":"## Hello 👋\nWelcome to Blackprint Editor!<br>\nThis documentation still being improved 😺<br>\nCurrently this documentation is written for JavaScript\n\n---\n\n**Blackprint** is a visual programming interface that can help you experimenting with multiple libraries by connecting cables. No need to write code, just import module, put the nodes, and begin routing the data flow ✨\n\n> The ecosystem is still improving, we're looking for open source contributor like you to create new useful nodes or module that can help the others. Feel free to help contributing to documentation or unit test.\n\n---\n\n**Blackprint project** is separated into multiple components:\n|  |  |\n|---|---|\n|1. Engine|A runtime that managing the data flow between nodes|\n|2. Modules|Collection of nodes that was handling external API or libraries|\n|3. Sketch|Single container of nodes/diagrams and the cables|\n|4. Editor|A collection of tools that can help you for using Blackprint|\n\nEach of the component have different functionality, so if you want to create an issue please make sure to fill it on the correct repository.\n\n---\n\nFeel free to create a new [discussion](https://github.com/Blackprint/Blackprint/discussions) on Blackprint repository, or join the Discord server.\n\n<a href='https://discord.gg/cz9rh3a7d6'><img src='https://img.shields.io/discord/915881655921704971.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2' height='20'></a>"},"Settings":{"content":"## Blackprint settings\nYou can modify the settings like below:\n```js\nBlackprint.settings(name, value);\n```\n\n|Name|Value Type|Availability|Description|\n|---|---|---|---|\n|`visualizeFlow`|Boolean|Sketch|Turn this off if you don't want to see glowing cables that visualize the data flow|\n|`windowless`|Boolean|Sketch|In case you run Blackprint Sketch not in a browser, you must set this to true. Otherwise Blackprint may throw error on some environment like Node.js or Deno|"},"Sketch":{"content":"> Blackprint Sketch is using ScarletsFrame for the HTML templating system.\n\nBlackprint Sketch is only available for modern Browser, it can also running on Node.js for unit testing. Chromium based browser is more recommended, and there will be no support for IE11 or old Safari browser.\n\n## Load Blackprint required files\n\n<docs-md-tabs>\n<div class=\"tabs\"><div sf-each=\"x in tabs\">{{ x }}</div></div>\n\n<div tab=\"Browser\">\n\nYou need to put this in the `<head>` tag.\n```html\n<!-- If you're going to use Sketch, the framework must be loaded before the engine -->\n<script src=\"https://cdn.jsdelivr.net/npm/scarletsframe@0.35\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/@blackprint/engine@0.10\" crossorigin=\"anonymous\"></script>\n\n<!-- Load Sketch after the Engine -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@blackprint/sketch@0.10/dist/blackprint.sf.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/@blackprint/sketch@0.10/dist/blackprint.min.js\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/@blackprint/sketch@0.10/dist/blackprint.sf.js\" crossorigin=\"anonymous\"></script>\n```\n\n</div><div tab=\"Unit Test\">\n\nIf you want to import Blackprint Sketch for unit testing in Node.js, you also need to set the Blackprint to use `windowless` mode. I also recommend for using Jest.\n```js\n/**\n * @jest-environment jsdom\n */\nwindow.ResizeObserver = class{}; // Polyfill with empty class\n\n// This will automatically load ScarletsFrame + Engine + Sketch\nrequire(\"@blackprint/sketch\");\n\n// Disable loader for browser, as we're testing with Node.js\nsf.loader.turnedOff = true;\nsf.loader.task = false;\n\n// Let Blackprint know we're running in windowless environment\nBlackprint.settings('windowless', true);\n\n// Force Blackprint module to load from node_modules\nBlackprint.Environment.loadFromURL = false;\n\n// Force to browser environment\nBlackprint.Environment.isBrowser = true;\nBlackprint.Environment.isNode = false;\n\n// Begin testing, below can be different depends on what you want to test\ntest(\"Load required modules\", async () => {\n\t// Alternative for Blackprint.loadModuleFromURL(...);\n\tawait import(\".../dist/nodes-module-name.mjs\"); // For Browser/Node.js\n\tawait import(\".../dist/nodes-module-name.sf.mjs\"); // For Browser UI\n\n\t// Wait and avoid Jest's test environment being torn down\n\tawait Blackprint.getContext('ModuleName');\n\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\n\t// Check if the nodes has been registered\n\texpect(Blackprint.nodes['ModuleName']).toBeDefined();\n});\n```\n\n</div></docs-md-tabs>\n\n## Create Instance\n`Blackprint.Sketch` does extends `Blackprint.Engine` class, that's mean the API and functionaily is similar with the Engine instance but with extended feature like having a User Interface for the nodes, cable, ports and also handling user interaction for managing the instance.\n\n```js\nvar instance = new Blackprint.Sketch();\n\n// Get the container and attach it into the DOM\ndocument.body.appendChild(instance.cloneContainer());\n```\n\nIf you want to create a minimap, you can just call `instance.cloneContainer(true)` for the same instance and scale it down.\n\n## Import Blackprint nodes\nIf you have exported Blackprint into JSON, then you can easily import it like below:\n```js\n// After imported it will automatically appended into the DOM container\nvar nodes = sketch.importJSON('{...}');\n// nodes = [iface, iface, ...]\n\n/**\n * Import nodes structure and connection from JSON\n * @param json JSON data\n * @param options additional options for importing JSON data\n */\nimportJSON(json: string | object, options?: {\n\t/** Set this to false if you want to clear current instance before importing */\n\tappendMode?: Boolean,\n\t/** Skip importing environment data if exist on the JSON */\n\tnoEnv?: Boolean,\n\t/** Skip importing module URL (in case if you already imported the nodes from somewhere) */\n\tnoModuleJS?: Boolean,\n}): Promise<Array<Interface>>;\n```\n\n## Create single Blackprint node\nTo create new node and put it on the DOM you can call\n```js\nlet iface = sketch.createNode('MyModule/Math/Multiply', {/* optional options */});\n\n/**\n * Create a node from a namespace\n * @param namespace Node namespace\n * @param options additional options\n */\ncreateNode(namespace: string, options?: {\n\tdata?: object, // You can access this data in a class with `imported(data){...}`\n\tx?: number, // Node X position\n\ty?: number, // Node Y position\n\tid?: number, // Node ID\n}): Interface;\n```\n\n```js\nvar iface = sketch.createNode('Math/Multiply', {x:20, y:20});\n// iface.node == the node handler\n```\n\n## Get created node and cable list\n**Blackprint Sketch** does expose model and components through sketch.scope('modelName'). Below is reactive list, so if you remove or modify the array it will also modify the sketch container. It's **not recommended** to modify the list directly with `.push, .splice, .pop` or other array manipulation function. You shoudn't reference to the node by index too when using this list, as the index may got changed.\n```js\nvar ifaceList = sketch.scope('nodes').list; // as Array<Interface>\nvar cableList = sketch.scope('cables').list; // as Array<Cable>\n```\n\n## Refresh node and cable position\nWhen some node size was changed usually the cable is not in the right position, in order to fix it you can call:\n```js\nsketch.recalculatePosition();\n```\n\n## Export Blackprint nodes\nCurrently you can export your diagram only with Blackprint Sketch. The nodes can be exported as JSON, but it's like the node namespace, position, value, and the connections.\n```js\nvar str = sketch.exportJSON();\n// {\"Math/Multiply\":[...], ...}\n\n/**\n * Export current instance's nodes structure and connections to JSON\n * @param options additional options\n */\nexportJSON(options?: {\n\t/** Export selected nodes only */\n\tselectedOnly?: Boolean,\n\n\t/** Exclude node namespace */\n\texclude?: string[],\n\n\t/** JSON's whitespace/tabsize length */\n\tspace?: Number,\n\n\t/** Set this to true if you want to also export Blackprint enviroment variables */\n\tenvironment?: Boolean,\n\n\t/** Set this to false if you don't want to include .js module URL in the export */\n\tmodule?: any,\n\n\t/** Set this to false if you don't want to export node's (x,y) position */\n\tposition?: any,\n\n\t/** Set this to false if you don't want to export custom function */\n\texportFunctions?: any,\n\n\t/** Set this to false if you don't want to export custom variable */\n\texportVariables?: any,\n\n\t/** Set this to true if you don't want to serialize the object to JSON */\n\ttoRawObject?: any,\n\n\t/** JSON.stringify's replacer */\n\treplacer?: any,\n\n\t/** Simplify the exported JSON for use in JavaScript */\n\ttoJS?: any,\n}): String | object;\n```\n\n## Add event listener to the instance\nYou can also register an event that exist on Engine class for your Sketch instance. Below is some event addition for Sketch instance.\n\n|Event Name|Event Object|Description|\n|---|---|---|\n|`container.selection`|`{ cables: Array, nodes: Array }`|User is selecting some nodes and cables|\n|`error`|`{ type: String, data: Object }`|An error happened on the instance|\n|`port.default.changed`|`{ port: Port }`|Default port value was changed|\n|`cable.create.branch`|`{ event: Event, cable: Cable }`|A cable was splitted and a cable branch was created|\n|`cable.dropped`|`{ port: Port, cable: Cable, event: Event }`|A cable that was created by user interaction was dropped by user|\n|`cable.drag`|`{ cable: Cable }`|A cable is being dragged by user|\n|`node.move`|`{ iface: Interface, event: Event }`|A node is moved by user interaction|\n|`node.resize`|`{ items: Array }`|Some nodes get resized|\n|`node.click`|`{ iface: Interface, event: Event }`|User clicked the node header|\n|`node.hover`|`{ iface: Interface, event: Event }`|User is hovering/focus the node header|\n|`node.unhover`|`{ iface: Interface, event: Event }`|User is leaving focus the node header|\n|`port.hover`|`{ port: Port, event: Event }`|User is hovering/focus the port element|\n|`port.unhover`|`{ port: Port, event: Event }`|User is leaving focus the port element|\n|`node.function.open`|<x-code2>{<x-t>event: Event,</x-t><x-t>iface: Interface,</x-t><x-t>function: BPFunction</x-t>}</x-code2>|User was double clicked a function node to open it|\n\nBelow is an example on how to register event on the instance:\n```js\n// Optional, but recommended to avoid re-register similar listener\nlet EventSlot = {slot: \"myLibraryName\"};\nlet instance = new Blackprint.Sketch();\n\ninstance.on('node.function.open', EventSlot, async function(event){\n\tlet name = ev.iface.namespace.split('/').join('-');\n\tname += '-'+ev.iface.uniqId;\n\n\t// Go to a new page for viewing inside of function node\n\tawait views.goto(\"/sketch/node-\"+name, {\n\t\tbpInstance: ev.iface.bpInstance\n\t});\n});\n```\n\nGlobal event\n|Event Name|Event Object|Description|\n|---|---|---|\n|`menu.create.node`|<x-code2>{<x-t>list: Object,</x-t><x-t>menu: Array,</x-t><x-t>sketch: Sketch,</x-t><x-t>event: Event,</x-t><x-t>options: Object,</x-t><x-t>preventDefault: Callback</x-t>}</x-code2>|Internal Blackprint is creating a menu for node suggestion|\n\nBelow is an example on how to register event into Blackprint:\n```js\nBlackprint.on('menu.create.node', EventSlot, function(event){\n\tlet { list, isSuggestion } = event;\n\tif(!isSuggestion) return;\n\n\tdelete list['Example']; // Delete \"Example/*\" nodes namespace list from node suggestion\n});\n```"}})})();