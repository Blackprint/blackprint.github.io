// Wrap all .js scripts until _z_end.js
// This will run after all script was loaded
$(function(){

// Blackprint.space = Namespace (https://github.com/ScarletsFiction/ScarletsFrame/wiki/Namespace)
// sketch.scope = shortcut to obtain your model scope/context

var sketch = window.sketch = new Blackprint.Sketch();
sketch.settings('visualizeFlow', true);
var hasTouchScreen = false;
if (navigator.maxTouchPoints !== void 0)
    hasTouchScreen = navigator.maxTouchPoints > 0;
else if (navigator.msMaxTouchPoints !== void 0)
    hasTouchScreen = navigator.msMaxTouchPoints > 0;
else {
    var mQ = window.matchMedia && matchMedia("(pointer:coarse)");
    if (mQ && mQ.media === "(pointer:coarse)")
        hasTouchScreen = !!mQ.matches;
    else {
        // Fall back to user agent sniffing
        var UA = navigator.userAgent;
        hasTouchScreen = (
            /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
            /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
        );
    }
}

if(hasTouchScreen)
	$(document.body).addClass('disable-effect');
// Nodes here registered as 'example' namespace

Blackprint.registerNode('example/math/multiply', function(handle, node){
	node.title = "Multiply";
	// Let's use default node interface

	// Handle all output port here
	handle.outputs = {
		Result:Number,
	};

	// Handle all input port here
	var inputs = handle.inputs = {
		Exec: function(){
			handle.outputs.Result = multiply();
			console.log("Result has been set:", handle.outputs.Result);
		},
		A: Number,
		B: Blackprint.PortValidator(Number, function(val){
			// Executed when inputs.B is being obtained
			// And the output from other node is being assigned
			// as current port value in this node
			console.log(node.title, '- Port B got input:', val);
			return Number(val);
		}),
	};

	// Your own processing mechanism
	function multiply(){
		console.log('Multiplying', inputs.A, 'with', inputs.B);
		return inputs.A * inputs.B;
	}

	// When any output value from other node are updated
	// Let's immediately change current node result
	handle.update = function(cable){
		handle.outputs.Result = multiply();
	}

	// Event listener can only be registered after handle init
	handle.init = function(){
		node.on('cable.connect', function(cable){
			console.log(`Cable connected from ${cable.owner.node.title} (${cable.owner.name}) to ${cable.target.node.title} (${cable.target.name})`);
		});
	}

	// If you want to test it or play around from the browser console
	setTimeout(function(){
		if(node.x === void 0)
			console.log('Node from Interpreter:', node);
		else
			console.log('Node from Sketch:', node);
	}, 10);
});

Blackprint.registerNode('example/math/random', function(handle, node){
	node.title = "Random";
	node.description = "Number (0-100)";

	// Let's use default node interface

	handle.outputs = {
		Out:Number
	};

	var executed = false;
	handle.inputs = {
		'Re-seed':function(){
			executed = true;
			handle.outputs.Out = Math.round(Math.random()*100);
		}
	};

	// When the connected node is requesting for the output value
	handle.request = function(port, node){
		// Only run once this node never been executed
		// Return false if no value was changed
		if(executed === true)
			return false;

		console.warn('Value request for port:', port.name, "from node:", node.title);

		// Let's create the value for him
		handle.inputs['Re-seed']();
	}
});

Blackprint.registerNode('example/display/logger', function(handle, node){
	node.title = "Logger";
	node.description = 'Print anything into text';

	// Let's use ../nodes/logger.js
	node.type = 'logger';

	handle.inputs = {
		Any: Blackprint.PortListener(function(port, val){
			console.log("I connected to", port.name, "port from", port.node.title, "that have new value:", val);

			// Let's take all data from all connected nodes
			// Instead showing new single data-> val
			refreshLogger(handle.inputs.Any);
		})
	};

	function refreshLogger(val){
		if(val === null)
			node.log = 'null';
		else if(val === void 0)
			node.log = 'undefined';
		else if(val.constructor === Function)
			node.log = val.toString();
		else if(val.constructor === String || val.constructor === Number)
			node.log = val;
		else
			node.log = JSON.stringify(val);
	}

	handle.init = function(){
		// Let's show data after new cable was connected or disconnected
		node.on('cable.connect cable.disconnect', function(){
			console.log("A cable was changed on Logger, now refresing the input element");
			refreshLogger(handle.inputs.Any);
		});
	}
});

Blackprint.registerNode('example/button/simple', function(handle, node){
	// node = under ScarletsFrame element control
	node.title = "Button";

	// Let's use ../nodes/button.js
	node.type = 'button';

	// handle = under Blackprint node flow control
	handle.outputs = {
		Clicked:Function
	};

	// Proxy event object from: node.clicked -> handle.clicked -> outputs.Clicked
	handle.clicked = function(ev){
		console.log('button/simple: got', ev, "time to trigger to the other node");
		handle.outputs.Clicked(ev);
	}
});

Blackprint.registerNode('example/input/simple', function(handle, node){
	// node = under ScarletsFrame element control
	node.title = "Input";

	// Let's use ../nodes/input.js
	node.type = 'input';

	// handle = under Blackprint node flow control
	handle.outputs = {
		Changed:Function,
		Value:'', // Default to empty string
	};

	// Bring value from imported node to handle output
	handle.imported = function(){
		if(node.options.value)
			console.warn("Saved options as outputs:", node.options.value);

		handle.outputs.Value = node.options.value;
	}

	// Proxy string value from: node.changed -> handle.changed -> outputs.Value
	// And also call outputs.Changed() if connected to other node
	handle.changed = function(text, ev){
		// This node still being imported
		if(node.importing !== false)
			return;

		console.log('The input box have new value:', text);

		// node.options.value === text;
		handle.outputs.Value = node.options.value;

		// This will call every connected node
		handle.outputs.Changed();
	}
});

// Does nothing :3
Blackprint.registerNode('example/dummy/test', function(handle, node){
	node.title = "Do nothing";

	// PortName must different any port
	handle.inputs = {
		"Input 1":Boolean,
		"Input 2":String
	};

	handle.outputs = {
		"Output 1":Object,
		"Output 2":Number
	};

	handle.properties = {
		"Property 1":Boolean,
		"Property 2":Number
	};
});
var sampleImported = false;
var sampleList = {
	"Default sample": {"example/math/random":[{"id":0,"x":298,"y":73,"outputs":{"Out":[{"id":2,"name":"A"}]}},{"id":1,"x":298,"y":239,"outputs":{"Out":[{"id":2,"name":"B"}]}}],"example/math/multiply":[{"id":2,"x":525,"y":155,"outputs":{"Result":[{"id":3,"name":"Any"}]}}],"example/display/logger":[{"id":3,"x":763,"y":169}],"example/button/simple":[{"id":4,"x":41,"y":59,"outputs":{"Clicked":[{"id":2,"name":"Exec"}]}}],"example/input/simple":[{"id":5,"x":38,"y":281,"options":{"value":"saved input"},"outputs":{"Changed":[{"id":1,"name":"Re-seed"}],"Value":[{"id":3,"name":"Any"}]}}]},

};

// Sample will be imported when the 'ground' router going to '/page/:pageIndex'
function startImportSample(pageData){
	// console.log("Current router data:", pageData);

	if(sampleImported)
		return;

	sampleImported = true;

	// This could be string instead of object
	sketch.importJSON(sampleList['Default sample']);
}

// Autoload for Blackprint Interpreter
var interTest = window.interpreter = new Blackprint.Interpreter();

// Wait after ./register-handler.js was executed
setTimeout(function(){
	// Uncomment if we don't need sample
	return;

	// These nodes are the handler that registered from ./register-handler.js
	var registered = Blackprint.nodes;

	// We must register the node handler first to the interpreter instance
	interTest.registerNode('example/math/multiply', registered.math.multiply);
	interTest.registerNode('example/math/random', registered.math.random);
	interTest.registerNode('example/display/logger', registered.display.logger);
	interTest.registerNode('example/button/simple', registered.button.simple);
	interTest.registerNode('example/input/simple', registered.input.simple);

	interTest.importJSON(sampleList['Default sample']);

	setTimeout(function(){
		console.warn('The interpreter nodes on this console using default sample');
		console.warn('If you want to import your JSON, don\'t forget to .clearNodes() first');
		console.log(`For obtain interpreter node:%c
var node = interpreter.getNodes('example/button/simple')[0];
var input = interpreter.getNodes('example/input/simple')[0];
var logger = interpreter.getNodes('example/display/logger')[0];
`, "color: gray");
		console.log("To click the invisible button: %cnode.clicked()", "color: gray");
		console.log("To set the invisible input: %cinput.options.value = 'hello'", "color: gray");
		console.log("Or send the input to the handle output directly: %cinput.handle.outputs.Value = 'hello'", "color: gray");
		console.log("To get the logger value: %clogger.handle.inputs.Any", "color: gray");
	}, 2000);
}, 10);
var transitioning = 0;
function animatePageTransition(views){
	if(views.lastSibling !== void 0)
		$(views.lastSibling).animateKey('scaleDown', 0.6, function(){
			$(this).addClass('disable-anim');
		});

	$(views.showedSibling).removeClass('disable-anim').animateKey('scaleUpDown', {
		duration:0.6,
		delay:0.3,
		visible:false
	});

	// Make sure showed element is not hidden after animation
	clearTimeout(transitioning);
	transitioning = setTimeout(function(){
		transitioning = false;
		$(views.relatedDOM).removeClass('disable-anim');
	}, 1000);
}
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('button', {
	extend: Blackprint.Node,
	template: 'nodes/button.html'
}, function(self){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// To get the button element
	// self.$el('.button')

	// self.$el only available after component was initialized
	// self.init = function(){ ... }

	// Element event binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Element-Event
	self.clicked = function(ev){
		console.log("Element: 'Trigger' button clicked, going to run the handler");
		self.handle.clicked && self.handle.clicked(ev);
	}
});



// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('button', function(self){
	self.clicked = function(ev){
		console.log("Interpreter: 'Trigger' button clicked, going to run the handler");
		self.handle.clicked && self.handle.clicked(ev);
	}
});
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('input', {
	extend: Blackprint.Node,
	template: 'nodes/input.html'
}, function(self){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// Must be placed on 'options' if we want to export the properties as JSON
	self.options = {
		// Two way binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Input-Binding
		value:'',

		// Listener for two way binding when value from HTML input element is being received by the framework
		// I'm using this for auto scale the width/height of the textarea
		on$value:function(old, now){
			// Scale the input box depend on character length
			var el = self.$el('textarea');

			// Skip if textarea was larger than our auto control
			// I mean, if user have change the size manually
			if(el[0].offsetWidth > 150 || el[0].offsetHeight > 60)
				return;

			if(now.length < 8)
				el.attr('style', '');
			else if(now.length >= 8 && now.length < 14)
				el.attr('style', 'width:'+(10*now.length)+'px');
			else if(now.length >= 14)
				el.attr('style', 'width:140px;height:50px');
		}
	};

	self.textChanged = function(ev){
		self.handle.changed(ev.target.value);
	}

	// Add event listener to textarea after element initialized
	self.init = function(){
		// Only create if the Blackprint handler need this
		if(self.handle.changed)
			self.$el('textarea').on('input', self.textChanged);
	}
});



// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('input', function(self, bind){
	var theValue = '...';
	bind({
		options:{
			set value(val){
				theValue = val;

				if(self.handle.changed !== void 0)
					self.handle.changed(val);
			},
			get value(){
				return theValue;
			}
		}
	});
});
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('logger', {
	extend: Blackprint.Node,
	template: 'nodes/logger.html'
}, function(self){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// One way binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Input-Binding
	self.log = '...';

	// Listener when log value is being send to HTML input element by the framework
	// I'm using this for auto scale the width/height of the textarea
	self.m2v$log = function(old, now){
		// Scale the input box depend on character length
		var el = self.$el('textarea');

		// Skip if textarea was larger than our auto control
		// I mean, if user have change the size manually
		if(el[0].offsetWidth > 150 || el[0].offsetHeight > 60)
			return;

		if(now.length < 8)
			el.attr('style', '');
		else if(now.length >= 8 && now.length < 14)
			el.attr('style', 'width:'+(10*now.length)+'px');
		else if(now.length >= 14)
			el.attr('style', 'width:140px;height:50px');
	}
});



// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('logger', function(self, bind){
	bind({
		set log(val){
			console.log("Logger:", val);
		}
	});
});
var ground = new sf.views('vw-ground', 'ground');

// Increase views limit from 3 into 100
ground.maxCache = 100;

// https://github.com/ScarletsFiction/ScarletsFrame/wiki/Router-or-Views
ground.addRoute([
	{
	    path:'/',
	    template:'vw-ground/blackprint',

	    // Nested router for vw-sketch
	    'vw-sketch':[{
	    	path:'/page/:pageIndex',
	    	template:'Blackprint/page', // Import blackprint page
	    	on:{
	    		showed: function(){
	    			// Show sketch options
					sf.model('header').showOptions = true;

		    		// Start importing blackprint sample here
	    			startImportSample();
	    		},
	    		leaving: function(){
					sf.model('header').showOptions = false;
	    		}

	    		/*
	    		showed: Sketch container have been loaded,
	    		coming: The cable would have wrong position because the DOM still hidden,
	    		leaving: Maybe we can uninitialize something,
	    		hidden: Animate something maybe
	    		*/
	    	}
	    }]
	}, {
	    path:'/getting-started',
	    template:'vw-ground/getting-started'
	},
]).on('finish', function(){
	animatePageTransition(ground);
}).on('error', console.error);

sf.views.onCrossing = function(url, target){
	window.open(url, target).focus();
}
// https://www.npmjs.com/package/scarletsframe#initializedefine-model
sf.model('header', function(self, root){
	self.message = "Hello";
	self.description = "Developers! ";
	self.showOptions = false;

	self.info = {scale:100};

	var onHomepage;
	self.init = function(){
		sf.url.parse(); // Trigger to reparse current URL

		if(!sf.url.hashes.ground || sf.url.hashes.ground === '/'){
			setTimeout(function(){
				textAnimation("Let's getting started!");

				onHomepage = setInterval(function(){
					self.$el('.right').animateKey('fadeOut');
				}, 2000);
			}, 2000);
		}
		else{
			self.description = "Developers! ";
			textAnimation("Welcome to the example!");

			self.showOptions = true;

			sketch.scope('container').onScale = function(scale){
				self.info.scale = Math.round(scale*100);
			}
		}
	}

	self.toHome = function(){
		ground.goto('/');
	}

	self.toWorkspace = function(){
		clearInterval(onHomepage);

		ground.goto('/page/1', function(){
			self.description = 'Developers! ';
			setTimeout(function(){
				textAnimation("Welcome to the example!");
			}, 1000);
		});
	}

	function textAnimation(text){
		var description = text.split('');

		// Text animation
		var interval = setInterval(function(){
			self.description += description.shift();

			if(description.length === 0)
				clearInterval(interval);
		}, 50);
	}

	self.switchVFXActive = false;
	self.switchVFX = function(){
		self.switchVFXActive = !self.switchVFXActive;

		if(self.switchVFXActive){
			sketch.scope('container').$el.addClass('performance');
			self.visualizeActive = false;
			Blackprint.settings('visualizeFlow', false);
		}
		else sketch.scope('container').$el.removeClass('performance');
	}

	self.visualizeActive = true;
	self.visualizeFlow = function(){
		self.visualizeActive = !self.visualizeActive;
		Blackprint.settings('visualizeFlow', self.visualizeActive);
	}

	self.saveSketch = function(ev){
		sketch.scope('dropdown').show([{
			title:'Copy JSON',
			callback:function(){
				var temp = sketch.exportJSON();
				navigator.clipboard.writeText(temp);

				swal({
					title: "Copied to clipboard!",
					text: temp
				});
			}
		}, {
			title:'To File',
			callback:function(){
				var btn = document.createElement("a");
				var file = new Blob([sketch.exportJSON()], {type: 'application/json'});
				btn.href = URL.createObjectURL(file);
				btn.download = 'blackprint.json';
				btn.click();

				// Auto revoke after 10 sec
				setTimeout(function(){
					URL.revokeObjectURL(btn.href);
				}, 10000);
			}
		}], ev.x, ev.y);
	}

	self.loadSketch = function(ev){
		sketch.scope('dropdown').show([{
			title:'Append from JSON',
			callback:function(){
				swal({
					title:"Append from JSON",
					content: "input",
				}).then(function(val){
					sketch.importJSON(val);
				});
			}
		}, {
			title:'Import JSON',
			callback:function(){
				swal({
					title:"Import JSON",
					content: "input",
				}).then(function(val){
					if(!val)
						return;

					sketch.clearNodes();
					sketch.importJSON(val);
				});
			}
		}, {
			title:'From File',
			callback:function(){
				var el = document.createElement("input");
				el.setAttribute('type', 'file');
				el.onchange = function(){
					console.log(345, this);
				}
				el.click();
			}
		}], ev.x, ev.y);
	}
});
});
// End of compiled file
//# sourceMappingURL=myjs.min.js.map
