// Wrap all .js scripts until _z_end.js
// This will run after all script was loaded
$(function(){

// Blackprint.space = Namespace (https://github.com/ScarletsFiction/ScarletsFrame/wiki/Namespace)
// sketch.scope = shortcut to obtain your model scope/context

var sketch = window.sketch = new Blackprint.Sketch();
sketch.settings('visualizeFlow', true);
var hasTouchScreen = false;
if (navigator.maxTouchPoints !== void 0)
    hasTouchScreen = navigator.maxTouchPoints > 0;
else if (navigator.msMaxTouchPoints !== void 0)
    hasTouchScreen = navigator.msMaxTouchPoints > 0;
else {
    var mQ = window.matchMedia && matchMedia("(pointer:coarse)");
    if (mQ && mQ.media === "(pointer:coarse)")
        hasTouchScreen = !!mQ.matches;
    else {
        // Fall back to user agent sniffing
        var UA = navigator.userAgent;
        hasTouchScreen = (
            /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
            /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
        );
    }
}

if(hasTouchScreen)
	$(document.body).addClass('disable-effect');
// Nodes here registered as 'example' namespace

Blackprint.registerNode('example/math/multiply', function(node, iface){
	iface.title = "Multiply";
	// Let's use default node interface

	// Handle all output port here
	node.outputs = {
		Result: Number,
	};

	// Kind of shortcut
	const Output = node.outputs;

	// Handle all input port here
	const Input = node.inputs = {
		Exec: Blackprint.PortTrigger(function(){
			Output.Result = multiply();
			console.log("Result has been set:", Output.Result);
		}),
		A: Number,
		B: Blackprint.PortValidator(Number, function(val){
			// Executed when inputs.B is being obtained
			// And the output from other node is being assigned
			// as current port value in this node
			console.log(iface.title, '- Port B got input:', val);
			return Number(val);
		}),
	};

	// Your own processing mechanism
	function multiply(){
		console.log('Multiplying', Input.A, 'with', Input.B);
		return Input.A * Input.B;
	}

	// When any output value from other node are updated
	// Let's immediately change current node result
	node.update = function(cable){
		Output.Result = multiply();
	}

	// Event listener can only be registered after handle init
	node.init = function(){
		iface.on('cable.connect', function(port1, port2){
			console.log(`Cable connected from ${port1.iface.title} (${port1.name}) to ${port2.iface.title} (${port2.name})`);
		});
	}

	// If you want to test it or play around from the browser console
	setTimeout(function(){
		if(iface.x === void 0)
			console.log('Node from Interpreter:', iface);
		else
			console.log('Node from Sketch:', iface);
	}, 10);
});

Blackprint.registerNode('example/math/random', function(node, iface){
	iface.title = "Random";
	iface.description = "Number (0-100)";

	// Let's use default node interface

	const Output = node.outputs = {
		Out: Number
	};

	var executed = false;
	node.inputs = {
		'Re-seed': Blackprint.PortTrigger(function(){
			executed = true;
			Output.Out = Math.round(Math.random()*100);
		})
	};

	// When the connected node is requesting for the output value
	node.request = function(port, iface2){
		// Only run once this node never been executed
		// Return false if no value was changed
		if(executed === true)
			return false;

		console.warn('Value request for port:', port.name, "from node:", iface2.title);

		// Let's create the value for him
		node.inputs['Re-seed']();
	}
});

Blackprint.registerNode('example/display/logger', function(node, iface){
	iface.title = "Logger";
	iface.description = 'Print anything into text';

	// Let's use ../nodes/logger.js
	iface.interface = 'nodes/logger';

	const Input = node.inputs = {
		Any: Blackprint.PortArrayOf(null) // Any data type, and can be used for many cable
	};

	function refreshLogger(val){
		if(val === null)
			iface.log = 'null';
		else if(val === void 0)
			iface.log = 'undefined';
		else if(val.constructor === Function)
			iface.log = val.toString();
		else if(val.constructor === String || val.constructor === Number)
			iface.log = val;
		else
			iface.log = JSON.stringify(val);
	}

	node.init = function(){
		// Let's show data after new cable was connected or disconnected
		iface.on('cable.connect cable.disconnect', function(){
			console.log("A cable was changed on Logger, now refresing the input element");
			refreshLogger(Input.Any);
		});

		iface.inputs.Any.on('value', function(port){
			console.log("I connected to", port.name, "port from", port.iface.title, "that have new value:", port.value);

			// Let's take all data from all connected nodes
			// Instead showing new single data-> val
			refreshLogger(Input.Any);
		});
	}
});

Blackprint.registerNode('example/button/simple', function(node, iface){
	// node = under ScarletsFrame element control
	iface.title = "Button";

	// Let's use ../nodes/button.js
	iface.interface = 'nodes/button';

	// handle = under Blackprint node flow control
	const Output = node.outputs = {
		Clicked: Function
	};

	// Proxy event object from: node.clicked -> node.clicked -> outputs.Clicked
	node.clicked = function(ev){
		console.log('button/simple: got', ev, "time to trigger to the other node");
		Output.Clicked(ev);
	}
});

Blackprint.registerNode('example/input/simple', function(node, iface){
	// iface = under ScarletsFrame element control
	iface.title = "Input";

	// Let's use ../nodes/input.js
	iface.interface = 'nodes/input';

	// handle = under Blackprint node flow control
	const Output = node.outputs = {
		Changed: Function,
		Value: String, // Default to empty string
	};

	iface.options = {
		value:'...'
	};

	// Bring value from imported node to handle output
	node.imported = function(options){
		console.warn("Old options:", JSON.stringify(iface.options));
		console.warn("Imported options:", JSON.stringify(options));

		iface.options = options;
		Output.Value = options.value;
	}

	// Proxy string value from: node.changed -> node.changed -> outputs.Value
	// And also call outputs.Changed() if connected to other node
	node.changed = function(text, ev){
		// This node still being imported
		if(iface.importing !== false)
			return;

		console.log('The input box have new value:', text);

		// node.options.value === text;
		Output.Value = iface.options.value;

		// This will call every connected node
		Output.Changed();
	}
});

// Does nothing :3
Blackprint.registerNode('example/dummy/test', function(node, iface){
	iface.title = "Do nothing";

	// PortName must different any port
	node.inputs = {
		"Input 1": Boolean,
		"Input 2": String
	};

	node.outputs = {
		"Output 1": Object,
		"Output 2": Number
	};

	node.properties = {
		"Property 1": Boolean,
		"Property 2": Number
	};
});
var sampleList = window.sampleList = {
	"Default sample": {"example/math/random":[{"id":0,"x":298,"y":73,"outputs":{"Out":[{"id":2,"name":"A"}]}},{"id":1,"x":298,"y":239,"outputs":{"Out":[{"id":2,"name":"B"}]}}],"example/math/multiply":[{"id":2,"x":525,"y":155,"outputs":{"Result":[{"id":3,"name":"Any"}]}}],"example/display/logger":[{"id":3,"x":763,"y":169}],"example/button/simple":[{"id":4,"x":41,"y":59,"outputs":{"Clicked":[{"id":2,"name":"Exec"}]}}],"example/input/simple":[{"id":5,"x":38,"y":281,"options":{"value":"saved input"},"outputs":{"Changed":[{"id":1,"name":"Re-seed"}],"Value":[{"id":3,"name":"Any"}]}}]},
};

// Autoload for Blackprint Interpreter
var interTest = window.interpreter = new Blackprint.Interpreter();

console.log("-- Do you want to run a sample for interpreter-js?");
console.log("-- Call interpreterTest() from this console");

// Wait after ./register-handler.js was executed
window.interpreterTest = function(){
	// These nodes are the handler that registered from ./register-handler.js
	var registered = Blackprint.nodes;

	console.log("-- The sketch and the console was imported from same JSON example, but they're imported in different interpreter. Any modification from the sketch page will not change the imported console nodes.");
	sketch.clearNodes();
	sketch.importJSON(sampleList["Default sample"]);

	// We must register the node handler first
	Blackprint.Interpreter.registerNode('example/math/multiply', registered.example.math.multiply);
	Blackprint.Interpreter.registerNode('example/math/random', registered.example.math.random);
	Blackprint.Interpreter.registerNode('example/display/logger', registered.example.display.logger);
	Blackprint.Interpreter.registerNode('example/button/simple', registered.example.button.simple);
	Blackprint.Interpreter.registerNode('example/input/simple', registered.example.input.simple);

	interTest.importJSON(sampleList['Default sample']);

	setTimeout(function(){
		console.warn('The interpreter nodes on this console is using default sample\n> sampleList["Default sample"]');
		console.warn('If you want to import your JSON, don\'t forget to run interpreter.clearNodes() first');
		console.log(`For obtain interpreter node:%c
var button = interpreter.getNodes('example/button/simple')[0];
var input = interpreter.getNodes('example/input/simple')[0];
var logger = interpreter.getNodes('example/display/logger')[0];
`, "color: gray");
		console.log("To click on invisible button: %cbutton.clicked()", "color: gray");
		console.log("To set the invisible input: %cinput.options.value = 'hello'", "color: gray");
		console.log("Or send the input to the handle output directly: %cinput.const.Output.Value = 'hello'", "color: gray");
		console.log("To get the logger value: %clogger.const.Input.Any", "color: gray");
	}, 2000);
}
var transitioning = 0;
function animatePageTransition(views){
	if(views.lastSibling !== void 0)
		$(views.lastSibling).animateKey('scaleDown', 0.6, function(){
			$(this).addClass('disable-anim');
		});

	$(views.showedSibling).removeClass('disable-anim').animateKey('scaleUpDown', {
		duration:0.6,
		delay:0.3,
		visible:false
	});

	// Make sure showed element is not hidden after animation
	clearTimeout(transitioning);
	transitioning = setTimeout(function(){
		transitioning = false;
		$(views.relatedDOM).removeClass('disable-anim');
	}, 1000);
}
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('nodes/button', function(iface){
	// Property of this scope
	/* iface == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// To get the button element
	// iface.$el('.button')

	// iface.$el only available after component was initialized
	// iface.init = function(){ ... }

	// Element event binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Element-Event
	iface.clicked = function(ev){
		console.log("Element: 'Trigger' button clicked, going to run the handler");
		iface.node.clicked && iface.node.clicked(ev);
	}
});



// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('nodes/button', function(iface){
	iface.clicked = function(ev){
		console.log("Interpreter: 'Trigger' button clicked, going to run the handler");
		iface.node.clicked && iface.node.clicked(ev);
	}
});
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('nodes/input', function(iface){
	// Property of this scope
	/* iface == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// Must be placed on 'options' if we want to export the properties as JSON
	iface.options = {
		// Two way binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Input-Binding
		value:'',

		// Listener for two way binding when value from HTML input element is being received by the framework
		// I'm using this for auto scale the width/height of the textarea
		on$value:function(now){
			// Scale the input box depend on character length
			var el = iface.$el('textarea');

			// Skip if textarea was larger than our auto control
			// I mean, if user have change the size manually
			if(el[0].offsetWidth > 150 || el[0].offsetHeight > 60)
				return;

			if(now.length < 8)
				el.attr('style', '');
			else if(now.length >= 8 && now.length < 14)
				el.attr('style', 'width:'+(10*now.length)+'px');
			else if(now.length >= 14)
				el.attr('style', 'width:140px;height:50px');
		}
	};

	iface.textChanged = function(ev){
		iface.node.changed(ev.target.value);
	}

	// Add event listener to textarea after element initialized
	iface.init = iface.hotReloaded = function(){
		// Only create if the Blackprint handler need this
		if(iface.node.changed)
			iface.$el('textarea').on('input', iface.textChanged);
	}
});


// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('nodes/input', function(iface, bind){
	var theValue = '...';
	bind({
		options:{
			set value(val){
				theValue = val;

				if(iface.node.changed !== void 0)
					iface.node.changed(val);
			},
			get value(){
				return theValue;
			}
		}
	});
});
// == Blackprint Visual Interpreter ==
// You're allowed tp control related DOM element here
Blackprint.registerInterface('nodes/logger', function(iface){
	// Property of this scope
	/* iface == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	// One way binding-> https://github.com/ScarletsFiction/ScarletsFrame/wiki/Input-Binding
	iface.log = '...';

	// Listener when log value is being send to HTML input element by the framework
	// I'm using this for auto scale the width/height of the textarea
	iface.m2v$log = function(now){
		// Scale the input box depend on character length
		var el = iface.$el('textarea');

		// Skip if textarea was larger than our auto control
		// I mean, if user have change the size manually
		if(el[0].offsetWidth > 150 || el[0].offsetHeight > 60)
			return;

		if(now.length < 8)
			el.attr('style', '');
		else if(now.length >= 8 && now.length < 14)
			el.attr('style', 'width:'+(10*now.length)+'px');
		else if(now.length >= 14)
			el.attr('style', 'width:140px;height:50px');
	}
});



// == For Standalone Interpreter ==
// You must design this to support non-browser JavaScript
// As you can just copy/import this into Node.js or Deno script
Blackprint.Interpreter.registerInterface('nodes/logger', function(iface, bind){
	var log = '...';
	bind({
		get log(){
			return log;
		},
		set log(val){
			log = val;
			console.log("Logger:", val);
		}
	});
});
// https://www.npmjs.com/package/scarletsframe#initializedefine-model
sf.model('header', function(self, root){
	self.message = "Hello";
	self.description = "Developers! ";
	self.showOptions = false;

	self.info = {scale:100};

	var onHomepage;
	self.init = function(){
		sf.url.parse(true); // Trigger to reparse current URL

		if(!sf.url.routes.ground || sf.url.routes.ground === '/'){
			setTimeout(function(){
				textAnimation("Let's getting started!");

				onHomepage = setInterval(function(){
					self.$el('.right').animateKey('fadeOut');
				}, 2000);
			}, 2000);
		}
		else{
			self.description = "Developers! ";
			textAnimation("Welcome to the example!");

			self.showOptions = true;

			sketch.scope('container').onScale = function(scale){
				self.info.scale = Math.round(scale*100);
			}
		}
	}

	self.toHome = function(){
		ground.goto('/');
	}

	self.toWorkspace = function(){
		clearInterval(onHomepage);

		ground.goto('/page/1', function(){
			self.description = 'Developers! ';
			setTimeout(function(){
				textAnimation("Welcome to the example!");
			}, 1000);
		});
	}

	function textAnimation(text){
		var description = text.split('');

		// Text animation
		var interval = setInterval(function(){
			self.description += description.shift();

			if(description.length === 0)
				clearInterval(interval);
		}, 50);
	}

	self.cloneActive = false;
	self.cloneContainer = function(){
		self.cloneActive = !self.cloneActive;

		if(self.cloneActive){
			if(self.switchVFXActive === false)
				self.switchVFX();

			// Reset current container view
			var container = sketch.scope('container');
			container.pos.x = 0;
			container.pos.y = 0;
			container.scale = 1; // 100% scale

			var mini = sketch.cloneContainer(); // Clone 1

			// Remove the dropdown and SVG animation
			// from mini container
			$('sf-m[name="dropdown"], animate', mini).remove();

			// Clone into new window
			sf.window.create({
				title: "Cloned Sketch Container",
				templateHTML: sketch.cloneContainer() // Clone 2
			}, refreshViewport);

			// Put the mini container into DOM
			$('.mini-blackprint').removeClass('hidden').append(mini); // Clone 1

			// Refresh mini viewport size
			// I put it like this for a reason
			refreshViewport();
			function refreshViewport(){
				setTimeout(function(){
					container.pos.x = -0.1;
					setTimeout(function(){
						container.pos.x = 0;
					}, 500);
				}, 1000);
			}
		}
		else{
			$('.mini-blackprint').addClass('hidden').text('');
			sf.window.destroy();
		}
	}

	self.switchVFXActive = false;
	self.switchVFX = function(){
		self.switchVFXActive = !self.switchVFXActive;

		if(self.switchVFXActive){
			sketch.scope('container').$el.addClass('performance');
			self.visualizeActive = false;
			Blackprint.settings('visualizeFlow', false);
		}
		else sketch.scope('container').$el.removeClass('performance');
	}

	self.visualizeActive = true;
	self.visualizeFlow = function(){
		self.visualizeActive = !self.visualizeActive;
		Blackprint.settings('visualizeFlow', self.visualizeActive);
	}

	self.saveSketch = function(ev){
		sketch.scope('dropdown').show([{
			title:'Copy JSON',
			callback:function(){
				var temp = sketch.exportJSON();
				navigator.clipboard.writeText(temp);

				swal({
					title: "Copied to clipboard!",
					text: temp
				});
			}
		}, {
			title:'To File',
			callback:function(){
				var btn = document.createElement("a");
				var file = new Blob([sketch.exportJSON()], {type: 'application/json'});
				btn.href = URL.createObjectURL(file);
				btn.download = 'blackprint.json';
				btn.click();

				// Auto revoke after 10 sec
				setTimeout(function(){
					URL.revokeObjectURL(btn.href);
				}, 10000);
			}
		}], ev.x, ev.y);
	}

	self.loadSketch = function(ev){
		sketch.scope('dropdown').show([{
			title:'Append from JSON',
			callback:function(){
				swal({
					title:"Append from JSON",
					content: "input",
				}).then(function(val){
					sketch.importJSON(val);
				});
			}
		}, {
			title:'Import JSON',
			callback:function(){
				swal({
					title:"Import JSON",
					content: "input",
				}).then(function(val){
					if(!val)
						return;

					sketch.clearNodes();
					sketch.importJSON(val);
				});
			}
		}, {
			title:'From File',
			callback:function(){
				var el = document.createElement("input");
				el.setAttribute('type', 'file');
				el.onchange = function(){
					console.log(345, this);
				}
				el.click();
			}
		}], ev.x, ev.y);
	}
});
var ground = new sf.views('vw-ground', 'ground');

// Increase views limit from 3 into 100
ground.maxCache = 100;

// https://github.com/ScarletsFiction/ScarletsFrame/wiki/Router-or-Views
ground.addRoute([
	{
	    path:'/',
	    template:'vw-ground/ground',

	    // Nested router for vw-page
	    'vw-page':[{
	    	path:'/page/:pageIndex',
	    	template:'vw-ground/vw-page/sketch-page',
	    	on:{
	    		showed: function(){
	    			// Show sketch options
					sf.model('header').showOptions = true;
	    		},
	    		leaving: function(){
					sf.model('header').showOptions = false;
	    		}

	    		/*
	    		showed: Sketch container have been loaded,
	    		coming: The cable would have wrong position because the DOM still hidden,
	    		leaving: Maybe we can uninitialize something,
	    		hidden: Animate something maybe
	    		*/
	    	}
	    }, {
		    path:'/getting-started',
		    template:'vw-ground/vw-page/getting-started'
		}]
	}
]).on('finish', function(){
	animatePageTransition(ground);
}).on('error', console.error);

sf.views.onCrossing = function(url, target){
	window.open(url, target).focus();
}
var sampleImported = false;
sf.component('sketch-page', function(self){

	// Will run when <sketch-page> inserted on DOM
	self.init = function(){
		if(sampleImported)
			return;

		sampleImported = true;

		// This could be string instead of object
		// sketch.clearNodes();
		// sketch.importJSON(sampleList["Default sample"]);

		setTimeout(function(){
			sketch.importJSON(
{"Input/file":[{"id":0,"x":74,"y":26,"outputs":{"URL":[{"id":7,"name":"URL"}]}},{"id":1,"x":47,"y":557}],"WebAudio/input/microphone":[{"id":2,"x":21,"y":321}],"WebAudio/output/destination":[{"id":3,"x":597,"y":273}],"WebAudio/effect/PingPongDelay":[{"id":4,"x":322,"y":222,"options":{"mix":0.5,"time":0.3,"feedback":0.5},"outputs":{"Out":[{"id":3,"name":"In"}]}}],"example/button/simple":[{"id":5,"x":35,"y":139,"outputs":{"Clicked":[{"id":7,"name":"Play"}]}},{"id":6,"x":39,"y":225,"outputs":{"Clicked":[{"id":7,"name":"Pause"}]}}],"WebAudio/player":[{"id":7,"x":325,"y":34,"outputs":{"AudioNode":[],"Element":[],"VideoTrack":[{"id":9,"name":"VideoTrack"}],"AudioTrack":[]}}],"Input/slider-box":[{"id":8,"x":141,"y":417,"options":{"0":{"value":0,"min":-100,"max":100,"step":0.1},"1":{"value":0,"min":-100,"max":100,"step":0.1},"2":{"value":1,"min":-100,"max":100,"step":0.1},"3":{"value":1,"min":-100,"max":100,"step":0.1},"4":{"value":0,"min":-100,"max":100,"step":0.1}},"outputs":{"0":[{"id":10,"name":"x"}],"1":[{"id":10,"name":"y"}],"2":[{"id":10,"name":"ScaleX"}],"3":[{"id":10,"name":"ScaleY"}],"4":[{"id":10,"name":"Rotate"}]}}],"WebAudio/visualize/video":[{"id":9,"x":593,"y":25}],"Graphics/sprite":[{"id":10,"x":364,"y":374},{"id":11,"x":510,"y":544}],"Graphics/visualize/canvas":[{"id":12,"x":756,"y":269},{"id":13,"x":749,"y":490}],"Graphics/converter/gif":[{"id":14,"x":246,"y":643}],"decoration/text/notes":[{"id":15,"x":931,"y":27,"options":{"value":"Sorry it's messy here ｡ﾟ( ﾟ^∀^ﾟ)ﾟ｡\n\nFirst you need to open video file.\nTrigger the play, or connect AudioNode to PingPongDelay first.\n\nThe AudioNode can be connected directly to WebAudio Destination.\n\nMedia Player's Element can be connected to Sprite Source."}},{"id":16,"x":58,"y":737,"options":{"value":"To begin with GIF animation, open your GIF file.\n\nThen connect to GIF Player.\nConnect the Canvas to Sprite's Source\nthen connect the Sprite to Canvas Visualization."}}]}
		);}, 1000);
	}
});
});
// End of compiled file
//# sourceMappingURL=myjs.min.js.map
