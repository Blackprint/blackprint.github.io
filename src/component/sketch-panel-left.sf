## html
<sketch-panel-left class="panel {{ opened ? 'opened' : ''}}">
	<div class="content">
		<div class="preview" style="height: {{ scaledPreviewHeight }}px">
			<div class="zoom" style="transform: scale({{ previewScale }})">
				<sf-slot for="preview"></sf-slot>
			</div>
		</div>

		<div class="variable-list">
			<div class="title" @click="collapseSubPanel(this, true)"><i class="fa fa-chevron-down collapse-btn"></i> Variables</div>

			<div class="tree-view tree-item has-child collapsed">
				<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Environment ({{ _envVar.length }})</div>
				<div class="button" @click="Modal.goto('/environment-variables')"><i class="fa fa-plus-square" title="Create new environment variable"></i></div>

				<div class="tree-view tree-group" tree-section="environmentVar" @pointerdown="checkDragNode">
					<div class="tree-item" sf-each="val in _envVar" tree-item-key="{{ val.key }}">
						<div class="title"><i class="fa tree-icon"></i> {{ val.key }}</div>
					</div>
				</div>
			</div>

			<div class="tree-view tree-item has-child collapsed">
				<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Public ({{ variableCount }})</div>
				<div class="button" @click="createVariable(event, Blackprint.VarScope.Public)"><i class="fa fa-plus-square" title="Create new public/global variable"></i></div>

				<!-- /src/component/tree-list.sf -->
				<div class="tree-view tree-group" tree-section="variables" @pointerdown="checkDragNode">
					<div class="tree-item collapsed" tree-item-key="{{ key }}" sf-each="key, val in variables" style="display: {{ val.hidden ? 'none' : '' }}">
						<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

						{{@if val.constructor === Object:
							return new $TreeList({ parentKey: '', key, val });
						}}
					</div>
				</div>
			</div>

			<div class="tree-view tree-item has-child" style="display: {{ isFunctionSketch ? '' : 'none' }}">
				<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Function </div>

				<div class="tree-view tree-group">
					<div class="tree-view tree-item has-child collapsed">
						<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Input ({{ funcInput.length }}) </div>

						<div class="tree-view tree-group" tree-section="functionInputs" @pointerdown="checkDragNode">
							<div class="tree-item collapsed" tree-item-key="{{ val.name }}" sf-each="val in funcInput">
								<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ val.name }}</div>
							</div>
						</div>
					</div>
					<div class="tree-view tree-item has-child collapsed">
						<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Output ({{ funcOutput.length }}) </div>

						<div class="tree-view tree-group" tree-section="functionOutputs" @pointerdown="checkDragNode">
							<div class="tree-item collapsed" tree-item-key="{{ val.name }}" sf-each="val in funcOutput">
								<div class="title"><i class="fa tree-icon"></i> {{ val.name }}</div>
							</div>
						</div>
					</div>
					<div class="tree-view tree-item has-child collapsed">
						<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Shared ({{ functionSharedVariableLength }}) </div>
						<div class="button" @click="createVariable(event, Blackprint.VarScope.Shared)" title="Create new shared function variable"><i class="fa fa-plus-square"></i></div>

						<div class="tree-view tree-group" tree-section="sharedVariables" @pointerdown="checkDragNode">
							<div class="tree-item collapsed" tree-item-key="{{ key }}" sf-each="key, val in funcSharedVariable" style="display: {{ val.hidden ? 'none' : '' }}">
								<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

								{{@if val.constructor === Object:
									return new $TreeList({
										parentKey: '',
										key,
										val,
									});
								}}
							</div>
						</div>
					</div>
					<div class="tree-view tree-item has-child collapsed">
						<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> Private ({{ functionVariableLength }}) </div>
						<div class="button" @click="createVariable(event, Blackprint.VarScope.Private)" title="Create new private function variable"><i class="fa fa-plus-square"></i></div>

						<div class="tree-view tree-group" tree-section="privateVars" @pointerdown="checkDragNode">
							<div class="tree-item collapsed" tree-item-key="{{ key }}" sf-each="key, val in funcVariable" style="display: {{ val.hidden ? 'none' : '' }}">
								<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

								{{@if val.constructor === Object:
									return new $TreeList({
										parentKey: '',
										key,
										val,
									});
								}}
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="function-list collapsed">
			<div class="title" @click="collapseSubPanel(this, true)"><i class="fa fa-chevron-down collapse-btn"></i> Functions ({{ functionCount }})</div>
			<div class="button" @click="createFunction" title="Create new empty function node"><i class="fa fa-plus-square"></i></div>

			<!-- /src/component/tree-list.sf -->
			<div class="tree-view" tree-section="functions" @pointerdown="checkDragNode">
				<div class="tree-item collapsed" tree-item-key="{{ key }}" sf-each="key, val in functions"
					style="display: {{ val.hidden ? 'none' : '' }}">
					<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

					{{@if val.constructor === Object:
						return new $TreeList({
							parentKey: '', key, val
						});
					}}
				</div>
			</div>
		</div>
		<div class="event-list collapsed">
			<div class="title" @click="collapseSubPanel(this, true)"><i class="fa fa-chevron-down collapse-btn"></i> Events ({{ events.totalEvent }})</div>
			<div class="button" @click="createEvent" title="Create new empty event node"><i class="fa fa-plus-square"></i></div>

			<!-- /src/component/tree-list.sf -->
			<div class="tree-view" tree-section="events" @pointerdown="checkDragNode">
				<div class="tree-item collapsed" tree-item-key="{{ key }}" sf-each="key, val in events.treeList"
					style="display: {{ val.hidden ? 'none' : '' }}">
					<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

					{{@if val.constructor === Object:
						return new $TreeList({ parentKey: '', key, val });
					}}
				</div>
			</div>
		</div>
		<div class="node-list">
			<div class="title" @click="collapseSubPanel(this, true)"><i class="fa fa-chevron-down collapse-btn"></i> Nodes ({{ nodeCount }})</div>
			<div class="button" @click="createCustomNode" title="Create new node by using code editor "><i class="fa fa-plus-square"></i></div>

			<!-- /src/component/tree-list.sf -->
			<div class="tree-view" tree-section="nodes" @pointerdown="checkDragNode" @pointerover="nodeListHover"  @pointerleave="nodeListLeave">
				<div class="tree-item collapsed" sf-each="key, val in nodes"
					style="display: {{ val.hidden ? 'none' : '' }}">
					<div class="title" @click="collapseTree(this)"><i class="fa tree-icon"></i> {{ key }}</div>

					{{@if val.constructor === Object:
						return new $TreeList({ parentKey: '', key, val });
					}}
				</div>
			</div>
		</div>
	</div>

	<div class="opener" @click="opened ? closePanel(event) : openPanel()">
		<i class="fas fa-chevron-{{ opened ? 'left' : 'right' }}"></i>
	</div>
</sketch-panel-left>

## scss-global
body sketch-page > .panels sketch-panel-left {
	backdrop-filter: blur(1px); // Long CSS rule = more priority
}

sketch-page > .panels sketch-panel-left {
	position: absolute;
	display: flex;
	left: 0;
	width: 200px;
	height: 100%;
	transform: translate(-190px, 0);
	transition: 0.3s ease-out transform;
	// position: relative;
	background: #00000085;
	align-items: center;
	.content {
		align-self: baseline;
		visibility: hidden;
		display: flex;
		height: calc(100vh - 51px);
		flex-direction: column;
		.preview{
			// border-bottom: 1px dashed white;
			max-width: 200px;
			max-height: 200px;
			// overflow: hidden;
			.zoom{
	    		transform-origin: left top;
			}
		}
	}
	.variable-list, .function-list, .event-list, .node-list {
		color: #cbcbcb;
		position: relative;
		width: 190px;
		max-height: -webkit-fill-available;
		border-top: 1px solid #787878a3;
		padding: 5px 5px;
		// border-bottom: 1px dashed white;
		.title, .button{
			display: inline-block;
			cursor: pointer;
			white-space: nowrap;
		}
		& > .title {
			color: #e7e7e7;
    		font-weight: bold;
		}
		.collapse-btn {
			font-size: 14px;
			padding: 2px;
			width: 12px;
		}
		.button{
			margin-right: 10px;
			float: right;
		}
		.tree-view{
			position: relative;
			max-height: calc(100% - 22px);
			max-width: 185px;
			overflow: auto;
			font-size: 14px;
			&.collapsed > .tree-group {
				display: none;
			}
		}
		&.collapsed {
			.tree-view {
				display: none;
			}
		}
	}
	.variable-list {
		border-top: none;
	}
	.opener{
		cursor: pointer;
		height: 100%;
		display: flex;
		align-items: center;
		padding: 10px 0 10px 10px;
		position: absolute;
		right: 0;
		i {
			color: #ffffff70;
			position: absolute;
			right: 0;
			font-size: 12px;
			display: block;
		}
	}
	&.opened {
		transform: translate(0px, 0);
		.content {
			visibility: visible;
		}
	}
}
.anim-element sketch-page > .panels sketch-panel-left.opened .content {
	visibility: hidden;
}

## js-global
sf.component('sketch-panel-left', {template: #this.path}, function(My){
	let sketch = My.sketch = window.CurrentSketch;

	My.opened = true;
	My.preview = null;
	My.previewWidth = 200;
	My.previewScale = 1;
	My.scaledPreviewHeight = 1;

	let funcNodeInstance = sketch._funcMain?.node._funcInstance;
	if(funcNodeInstance != null)
		My.variables = funcNodeInstance.rootInstance.variables;
	else My.variables = sketch.variables;

	My.functions = sketch.functions;
	My.events = sketch.events || ({totalEvent: 0, treeList: {}});
	My.nodes = Blackprint.nodes;

	My.isFunctionSketch = sketch._funcMain != null;
	My.funcInput = sketch._funcMain?.input._portList ?? [];
	My.funcOutput = sketch._funcMain?.output._portList ?? [];
	My.funcSharedVariable = funcNodeInstance?.variables ?? {}; // shared function variables
	My.funcVariable = sketch.variables ?? {}; // private function variables

	My._envVar = Blackprint.Environment._list;
	My.functionSharedVariableLength = 0;
	My.functionVariableLength = 0;
	My.variableCount = 0;
	My.functionCount = 0;
	My.eventCount = 0;
	My.nodeCount = 0;

	function deepCount(obj, isNodes){
		let len = 0;
		if(obj.hidden) return len;

		for(let key in obj){
			let temp = obj[key];
			if(temp == null) continue;

			if(isNodes){
				if(temp instanceof Function)
					len++;
				else len += deepCount(temp, isNodes);
			}
			else {
				if(temp.constructor !== Object)
					len++;
				else len += deepCount(temp, isNodes);
			}
		}

		reSort(obj);
		return len;
	}

	function reSort(obj){
		if(obj._list) obj._list.sort((a, b) => a.localeCompare(b));
		obj.refresh?.();
	}

	let pendingRefreshModule;
	const refreshNodesCounter = () => {
		clearTimeout(pendingRefreshModule);

		pendingRefreshModule = setTimeout(async () => {
			await My.recalculateMenu();
			My.nodeCount = deepCount(Blackprint.availableNode, true);
		}, 500);
	}
	let pendingRefreshVars;
	const refreshVarsCounter = () => {
		clearTimeout(pendingRefreshVars);

		pendingRefreshVars = setTimeout(() => {
			My.variableCount = deepCount(My.variables);
			My.functionCount = deepCount(My.functions);
			My.eventCount = deepCount(My.events);

			if(My.isFunctionSketch){
				My.functionSharedVariableLength = deepCount(My.funcSharedVariable);
				My.functionVariableLength = deepCount(My.funcVariable);
			}
		}, 500);
	}

	sketch.on('json.imported', refreshVarsCounter);
	sketch.on('variable.new function.new', refreshVarsCounter);

	if(My.isFunctionSketch)
		funcNodeInstance.on('variable.new', refreshVarsCounter);

	Blackprint.on('module.added', refreshNodesCounter); // ToDo: use dot to separate event scope
	Blackprint.on('module.delete', refreshNodesCounter);
	Blackprint.on('module.update', refreshNodesCounter);
	Blackprint.on('bp_editorNodeAvailability', refreshNodesCounter);
	$(refreshNodesCounter); // Run when all script/page is loaded
	$(refreshVarsCounter); // Run when all script/page is loaded

	My.init = function(){
		let sketchPage = My.$el.parent('sketch-page')[0].model;
		sketchPage.panels.left = My;
		My.recalculateMenu();
		refreshNodesCounter();
	}

	let recheckPreviewSize;
	My.setPreview = function(el){
		if(el == null || My.preview !== el){
			recheckPreviewSize?.disconnect();
			recheckPreviewSize = null;
		}

		My.preview = el;
		My.previewScale = 1;
		My.scaledPreviewHeight = 1;

		if(recheckPreviewSize != null || el == null)
			return;

		let checkTime = 0;
		let checker = async function(){
			await $.afterRepaint();

			let width = el.clientWidth;
			let height = el.clientHeight;
			let scale = My.previewWidth / width;

			checkTime = Math.round(Date.now() / 100);

			My.previewScale = scale;
			My.scaledPreviewHeight = height * scale;
		}

		recheckPreviewSize = new ResizeObserver(function(items){
			if(checkTime === Math.round(Date.now() / 100)) return;
			setTimeout(checker, 200);
		});
		recheckPreviewSize.observe(el);

		setTimeout(checker, 100);
	}

	function removeBlur(){
		My.$el.css('backdrop-filter', 'none');
		setTimeout(()=> My.$el.css('backdrop-filter', ''), 300);
	}

	My.openPanel = function(){
		removeBlur();
		My.$el.parent('sketch-page').removeClass('left-menu-hide');
		My.opened = true;
		CurrentSketch.recalculatePosition();
	}

	My.closePanel = function(ev){
		removeBlur();
		ev.stopPropagation();
		My.$el.parent('sketch-page').addClass('left-menu-hide');
		My.opened = false;
		CurrentSketch.recalculatePosition();
	}

	My.collapseTree = function(el){
		el = el.nextElementSibling;
		if(el == null) return;

		let hidden;
		let parent = $(el.parentNode);

		if(parent.hasClass('tree-view') || parent.hasClass('tree-no-model'))
			hidden = !parent.hasClass('collapsed');
		else hidden = el.model.hidden = !el.model.hidden;

		if(hidden)
			parent.addClass("collapsed");
		else {
			if(el.model != null) reSort(el.parentNode.model);
			parent.removeClass("collapsed");
		}

		My.recalculateMenu();
	}

	My.collapseSubPanel = (el, isMain) => {
		let temp = $(el);
		let parent = temp.parent();
		parent.toggleClass("collapsed");

		if(!isMain) return;
		My.recalculateMenu();

		let collapseBtn = temp.find('.collapse-btn').removeClass('fa-chevron-down').removeClass('fa-chevron-right');

		if(parent.hasClass('collapsed'))
			collapseBtn.addClass('fa-chevron-right');
		else collapseBtn.addClass('fa-chevron-down');
	}

	My.recalculateMenu = async function(){
		let variableMenu = My.$el('.variable-list');
		let functionMenu = My.$el('.function-list');
		let eventMenu = My.$el('.event-list');
		let nodeMenu = My.$el('.node-list');

		if(variableMenu[0] == null) return;

		let menuContainer = variableMenu.parent();
		let maxContainerHeight = menuContainer[0].offsetHeight;
		let maxMenuHeight = Math.round(maxContainerHeight/4);

		variableMenu.css('max-height', ``);
		functionMenu.css('max-height', ``);
		eventMenu.css('max-height', ``);
		nodeMenu.css('max-height', ``);

		await $.afterRepaint();

		// collapsed menu => the height is lower than 40px
		let variableHeight = variableMenu[0].offsetHeight;
		let functionHeight = functionMenu[0].offsetHeight;
		let eventHeight = eventMenu[0].offsetHeight;
		let nodeHeight = nodeMenu[0].offsetHeight;

		let mH = maxMenuHeight;
		if(
			(variableHeight < mH && functionHeight < mH && eventHeight < mH && nodeHeight < mH)
			|| (variableHeight > mH && functionHeight < mH && eventHeight < mH && nodeHeight < mH)
			|| (variableHeight < mH && functionHeight > mH && eventHeight < mH && nodeHeight < mH)
			|| (variableHeight < mH && functionHeight < mH && eventHeight > mH && nodeHeight < mH)
			|| (variableHeight < mH && functionHeight < mH && eventHeight < mH && nodeHeight > mH)
		){
			variableMenu.css('max-height', `${maxContainerHeight-nodeHeight-functionHeight-eventHeight-10}px`);
			functionMenu.css('max-height', `${maxContainerHeight-variableHeight-nodeHeight-eventHeight-10}px`);
			eventMenu.css('max-height', `${maxContainerHeight-variableHeight-functionHeight-nodeHeight-10}px`);
			nodeMenu.css('max-height', `${maxContainerHeight-variableHeight-functionHeight-eventHeight-10}px`);
		}
		else{
			variableMenu.css('max-height', `${maxMenuHeight-10}px`);
			functionMenu.css('max-height', `${maxMenuHeight-10}px`);
			eventMenu.css('max-height', `${maxMenuHeight-10}px`);
			nodeMenu.css('max-height', `${maxMenuHeight-10}px`);
		}
	}

	My.nodeListLeave = ev => {
		if(ev.pressure === 0) ToolTip.set();
	};
	My.nodeListHover = ev => {
		if(ev.pressure !== 0) return; // Run on hover only, and no button click

		if(!ev.target.classList.contains('title'))
			return ToolTip.set(false);

		let itemEl = $(ev.target.parentNode);
		if(itemEl.hasClass('has-child'))
			return ToolTip.set(false);

		let key = itemEl.attr('tree-item-key');
		let parentKey = itemEl[0].parentNode.model.parentKey;

		let keys = parentKey.split('/');
		keys.push(key);

		let docs = Blackprint._utils.getDeepProperty(Blackprint._docs, keys);
		if(docs == null)
			return ToolTip.set(false);

		ToolTip.set(docs.description, ev, 'basic');
	};

	My.checkDragNode = ev => {
		let focus = ev.target;
		if(focus.nextElementSibling != null) return;

		focus = $(focus);

		let section = focus.parent('.tree-view').attr('tree-section');
		let itemEl = focus[0].parentNode;
		let key = itemEl.getAttribute('tree-item-key');
		if(key == null) return;

		let parent = focus.parent(".tree-item.has-child > tree-list, .tree-view > .tree-item")[0];
		if(parent == null) return;

		let endEvent = 'pointerup';
		if(ev.pointerType === 'touch')
			endEvent = 'touchend';

		ToolTip.set("Create node");
		$(sf.Window).once(endEvent, evUp => {
			ToolTip.set();

			let targetEl = evUp.target;
			if(endEvent === 'touchend'){
				let { clientX, clientY } = evUp.changedTouches[0];
				evUp.clientX = clientX;
				evUp.clientY = clientY;
				targetEl = document.elementFromPoint(clientX, clientY);
			}

			if(targetEl.closest('sketch-page') == null) return;
			if(targetEl.closest('sf-m.cables') != null){
				let parentKey = parent.model.parentKey;
				let namespace = !!parentKey ? (parentKey + '/' + key) : key;

				$.afterRepaint().then(function(){
					let offset = targetEl.getBoundingClientRect();
					let container = sketch.scope('container');
					let posX = (evUp.clientX - offset.x) / container.scale;
					let posY = (evUp.clientY - offset.y) / container.scale;
					let nodeOptions = { x: posX, y: posY };

					if(section === 'nodes'){
						sketch.createNode(namespace, nodeOptions);
					}
					else if(section === 'functions'){
						itemEl.model.createNode(sketch, nodeOptions);
					}
					else if(section === 'variables' || section === 'sharedVariables' || section === 'privateVars'){
						let scope;
						if(section === 'variables') scope = 0;
						else if(section === 'sharedVariables') scope = 2;
						else if(section === 'privateVars') scope = 1;

						nodeOptions.data = { name: namespace, scope };
						DropDown.show([{
							title: "Get " + namespace, callback(){
								sketch.createNode('BP/Var/Get', nodeOptions);
							}
						}, {
							title: "Set " + namespace, callback(){
								sketch.createNode('BP/Var/Set', nodeOptions);
							}
						}], {x: evUp.clientX, y: evUp.clientY, event: evUp});
					}
					else if(section === 'environmentVar'){
						nodeOptions.data = { name: key };
						DropDown.show([{
							title: "Get " + key, callback(){
								sketch.createNode('BP/Env/Get', nodeOptions);
							}
						}, {
							title: "Set " + key, callback(){
								sketch.createNode('BP/Env/Set', nodeOptions);
							}
						}], {x: evUp.clientX, y: evUp.clientY, event: evUp});
					}
					else if(section === 'functionInputs'){
						nodeOptions.data = { name: key };
						sketch.createNode('BP/FnVar/Input', nodeOptions);
					}
					else if(section === 'functionOutputs'){
						nodeOptions.data = { name: key };
						sketch.createNode('BP/FnVar/Output', nodeOptions);
					}
					else if(section === 'events'){
						nodeOptions.data = { namespace: namespace };
						DropDown.show([{
							title: "Listen " + key, callback(){
								sketch.createNode('BP/Event/Listen', nodeOptions);
							}
						}, {
							title: "Emit " + key, callback(){
								sketch.createNode('BP/Event/Emit', nodeOptions);
							}
						}], {x: evUp.clientX, y: evUp.clientY, event: evUp});
					}
					else console.error("Unhandled side panel section:", section);
				});
			};
		});
	}

	My.createVariable = async (ev, scope) => {
		let val = await Swal.fire({
			title: "Variable Name:",
			inputPlaceholder: scope === Blackprint.VarScope.Public
				? "MyApp/Custom/Variable" : "MyApp_Custom_Variable",
			input: "text",
		});

		val = val.value;
		if(!val) return;

		let funcInstance = sketch._funcMain?.node._funcInstance;
		let rootInstance = funcInstance?.rootInstance ?? sketch;

		if(scope === Blackprint.VarScope.Public)
			return rootInstance.createVariable(val);
		else if(scope === Blackprint.VarScope.Shared || scope === Blackprint.VarScope.Private)
			return funcInstance.createVariable(val, { scope });
		else throw new Error("Unhandled scope: " + scope);

		My.recalculateMenu();
	}

	My.createFunction = async ev => {
		let val = await Swal.fire({
			title: "Function Name:",
			inputPlaceholder: "MyApp/Custom/Function",
			input: "text",
		});

		val = val.value;
		if(!val) return;

		let rootInstance = sketch._funcMain?.node._funcInstance.rootInstance ?? sketch;
		rootInstance.createFunction(val, {description: "No description"});

		My.recalculateMenu();
	}

	My.createEvent = async ev => {
		let val = await Swal.fire({
			title: "Event Namespace:",
			inputPlaceholder: "MyApp/Custom/Event",
			input: "text",
		});

		val = val.value;
		if(!val) return;

		let rootInstance = sketch._funcMain?.node._funcInstance.rootInstance ?? sketch;
		rootInstance.events.createEvent(val);

		My.recalculateMenu();
	}

	My.createCustomNode = ev => {
		Modal.goto('/custom-node-editor');
	}
});