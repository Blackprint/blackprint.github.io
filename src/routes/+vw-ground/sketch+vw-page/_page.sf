## html
<sketch-page>
	<!-- This element will be replaced with 'My.space' -->
	<sf-slot for="space"></sf-slot>

	<!-- Panels -->
	<div class="panels {{ !miniViewer.topRightHidden && 'has-minimap' }}">
		<!-- /src/component/sketch-panel-left.sf -->
		<sketch-panel-left></sketch-panel-left>

		<!-- /src/component/sketch-panel-bottom.sf -->
		<sketch-panel-bottom></sketch-panel-bottom>

		<!-- /src/component/sketch-panel-right.sf -->
		<sketch-panel-right></sketch-panel-right>
	</div>

	<div class="mini-blackprint disable-effect {{ miniViewer.topRightHidden && 'hidden' }}">
		<!-- Will be replaced with element returned by Blackprint.cloneContainer(true) -->
		<sf-slot for="miniViewer.topRight"></sf-slot>
	</div>
</sketch-page>

## scss-global
sketch-page{
	.mini-blackprint{
		width: 240px;
		height: 190px;
		position: absolute;
		top: 5px;
		right: 0;
		overflow: hidden;
		box-shadow: 0 0 6px #ffffff6b;
		background: #ffffff40;
		border-radius: 10px;

		sf-m[name="container"]{
			pointer-events: none;
		}

		&.hidden{
			display: none;
		}
	}

	sf-m[name="container"] {
		margin-left: 200px;
	}

	.mini-blackprint, &.left-menu-hide {
		sf-m[name="container"]{
			margin-left: 0;
		}
	}

	&> .bottom-message {
		position: absolute;
		bottom: 0;
		color: #ababab;
		width: 100%;
		padding: 20px;
		text-align: center;
	}

	&> .panels {
		sketch-panel-left, sketch-panel-bottom, sketch-panel-right {
			z-index: 1;
			backdrop-filter: blur(1px);
			box-shadow: 0 0 8px 0 black;
		}
	}

	@media(max-width: 900px){
		&> .bottom-message {
			display: none;
		}
	}

	&> sf-space[blackprint] .bg-tile{
		background: url('/assets/img/background/tile.png');
		background-size: 100px;
		filter: brightness(38%);
		backface-visibility: hidden;
		opacity: 0.5;
		width: 100%;
		height: 100%;
		position: absolute;
	}
}

## js-global.router
={
	on:{
		coming(data){ // data === views.data
			console.log("Sketch page data:", data);
			let sketch = data.bpInstance ?? SketchList[data.page - 1];

			if(sketch == null || sketch._abandon) return;
			window.CurrentSketch = sketch;

			$('body > .background .tile').css('display', 'none');

			if(SketchSettings.showSketchMinimap){
				let ref = sketch.page.miniViewer;
				if(ref.topRight == null){
					ref.topRight = sketch.cloneContainer(true); // Clone and get the MiniMap

					// Remove the dropdown from minimap
					$('sf-m[name="dropdown"]', ref.topRight).remove();
				}

				ref.topRightHidden = false;
			}
		},
		leaving(targetURL){
			console.log("Leaving from sketch page data:", arguments);
			if(!/^\/sketch\//m.test(targetURL)){
				$('body > .background .tile').css('display', '');
				window.CurrentSketch = null;
			}
		}
	}
}

## js-global
// Blackprint.space = Space (https://github.com/ScarletsFiction/ScarletsFrame/wiki)
// sketch.scope = shortcut to obtain your model scope/context
var SketchList = [];
sf.component('sketch-page', function(My){
	My.miniViewer = {
		topRight: null,
		topRightHidden: true,
		on$topRight(now){
			if(now === null)
				return My.miniViewer.topRightHidden = true;

			My.miniViewer.topRightHidden = false;
			// now => <sf-space>
			// $(now)
		}
	};

	// URL: #page/sketch/{data.page}
	let sketch;
	if(views.data.bpInstance == null){
		if(views.data.page.startsWith('node-')){
			// Remove this page
			setTimeout(()=>{
				My.$el.parent('sf-page-view').remove();
				views.lastSibling = null;
			}, 500);

			this.CurrentSketch = {
				_abandon: true,
				variables:{},
				functions:{},
				on(){}
			};
			My.panels = {};
			return console.log("Returning to other page because bpInstance was not found");
		}

		sketch = My.sketch = SketchList[views.data.page - 1] ??= new Blackprint.Sketch();
	}
	else sketch = My.sketch = views.data.bpInstance;

	window.CurrentSketch = sketch;
	sketch.page = My;

	// Will be filled by each panel component after initialized
	My.panels = {left: null, bottom: null, right: null};

	// Please use sketch.on('...', callback) instead
	// This is used if no one listened to the event
	sketch._event.$_fallback = BlackprintEventFallback;

	// path: /src/global/SuggestNodeTypeCaster.js
	sketch.on('port.cable.test', {slot: 'bp-editor'}, SuggestNodeTypeCaster);
	sketch.on('port.hover node.hover', {slot: 'bp-editor'}, ev => {
		ev.instance = sketch;

		if(ev.port != null) PortHoverInfo(ev, true);
		if(ev.iface != null) NodeHoverInfo(ev, true);
	});
	sketch.on('port.unhover node.unhover', {slot: 'bp-editor'}, ev => {
		ev.instance = sketch;

		if(ev.port != null) PortHoverInfo(ev, false);
		if(ev.iface != null) NodeHoverInfo(ev, false);
	});
	sketch.on('cable.dropped', {slot: 'bp-editor'}, ev => {
		if(ev.event.ctrlKey || !ev.afterCreated || ev.cable.isRoute) return;
		if(ev.event.target.parentNode.model !== sketch.scope('cables')) return;

		let suggestedNode = Blackprint.Sketch.suggestNodeForPort(ev.port);
		container.nodeScope.menu(ev.event, suggestedNode);

		let ifaceList = sketch.ifaceList;
		let oldLastNode = ifaceList[ifaceList.length-1];

		setTimeout(() => {
			$(sf.Window).once('pointerup', function(){
				setTimeout(() => {
					let lastNode = ifaceList[ifaceList.length-1];
					if(oldLastNode === lastNode) return;

					let owner = ev.cable.owner;
					let sourcePort = owner.source;
					let targetPorts = lastNode[sourcePort === 'input' ? 'output' : 'input'];
					let compatiblePorts = [];

					if(targetPorts == null) return;

					for(let key in targetPorts){
						let port = targetPorts[key];
						if(isConnectablePort(owner.type, port.type))
							compatiblePorts.push(port);
					}
					
					// Auto connect if found only one compatible port
					if(compatiblePorts.length === 1){
						compatiblePorts[0].connectCable(ev.cable);

						// ToDo: remove this after Blackprint Sketch was updated
						if(sourcePort === 'input'){
							let port = compatiblePorts[0];
							let rect = port.findPortElement(targetPorts._portList.getElement(port)).getBoundingClientRect();
			
							let { offset, pos, scale } = port._scope('container');
							ev.cable.head1[0] = (rect.x + rect.width/2 - offset.x - pos.x) / scale;
							ev.cable.head1[1] = (rect.y + rect.height/2 - offset.y - pos.y) / scale;
						}
					}
				}, 100);
			});
		}, 200);
	});

	sketch.on('node.function.open', {slot: 'bp-editor'}, async ev => {
		let name = ev.iface.namespace.split('/').join('-');
		name += '-'+ev.iface.uniqId;

		await views.goto("/sketch/node-"+name, {
			bpInstance: ev.iface.bpInstance
		});
	});

	// This may cause one memory leak because this will never being cleared
	// But will only be replaced if the user is clicked other nodes
	sketch.on('node.click', {slot: 'bp-editor'}, ev => {
		My.panels.right.selectNode(ev.iface);
		NodeHoverInfo(ev, false);
	});

	Blackprint.settings('visualizeFlow', true);
	My.space ??= sketch.cloneContainer();

	let SketchPages = sf.model('sketch-pages');
	let container = sketch.scope('container');
	let header = sf.model('header');

	container.hideUnusedPort = sf.model('sketch-settings').hideUnusedPort;

	container.onScale = function(scale){
		header.info.scale = Math.round(scale * 100);
	}

	// Will run when <sketch-page> inserted on DOM
	My.init = async function(){
		let sfm = $(My.space.firstElementChild);
		if(!sfm.eq(0).hasClass('bg-tile')){
			sfm.prepend('<div class="bg-tile"></div>');
		}
	}

	My.importJSON = json => sketch.importJSON(json);
	My.clearNodes = ()=> sketch.clearNodes();

	My.cloneContainer = function(){
		let title = sketch._funcMain != null ? `"${sketch._funcMain.title}" Function` : `Main`;

		// Clone into new window
		new sf.Window({
			title: `Sketch: ${title}`,
			templateHTML: sketch.cloneContainer() // Clone 2
		});
	}

	sketch.on('node.menu', function({ iface, menu }){
		menu.unshift({
			title: !iface.id ? "Add ID" : "Modify ID",
			async callback(){
				let ref = await Swal.fire({
					title: "Write the new ID here",
					text: (iface.id ? "Current ID: "+iface.id : void 0),
					input: "text",
				});

				if(ref.isConfirmed === false) return;

				let sketch = SketchList[0];
				let val = ref.value;

				if(val === ''){
					delete sketch.iface[iface.id];
					iface.id = val;
					return;
				}

				if(sketch.iface[val] !== void 0)
					throw new Error("ID already exist");

				iface.id = val;
				sketch.iface[val] = iface;
			}
		}, {
			title: "View source code",
			async callback(){
				let code = await utils.openNodeSource(iface);
				if(!code) return;

				let editor = sf.model('custom-node-editor');
				editor.setValue(code);

				Modal.goto('/custom-node-editor');
			}
		});
	});
});