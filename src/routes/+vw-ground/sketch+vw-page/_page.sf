## html
<sketch-page>
	<!-- This element will be replaced with 'My.space' -->
	<sf-slot for="space"></sf-slot>

	<!-- Panels -->
	<div class="panels">
		<!-- /src/component/sketch-panel-left.sf -->
		<sketch-panel-left></sketch-panel-left>

		<!-- /src/component/sketch-panel-bottom.sf -->
		<sketch-panel-bottom></sketch-panel-bottom>

		<!-- /src/component/sketch-panel-right.sf -->
		<sketch-panel-right></sketch-panel-right>
	</div>
</sketch-page>

## scss-global
sketch-page{
	&> .bottom-message {
		position: absolute;
		bottom: 0;
		color: #ababab;
		width: 100%;
		padding: 20px;
		text-align: center;
	}

	&> .panels {
		sketch-panel-left, sketch-panel-bottom, sketch-panel-right {
			z-index: 1;
			backdrop-filter: blur(1px);
			box-shadow: 0 0 8px 0 black;
		}
	}

	@media(max-width: 900px){
		&> .bottom-message {
			display: none;
		}
	}

	&> sf-space[blackprint] .bg-tile{
		background: url('/assets/img/background/tile.png');
		background-size: 100px;
		filter: brightness(38%);
		backface-visibility: hidden;
		opacity: 0.5;
		width: 100%;
		height: 100%;
		position: absolute;
	}
}

## js-global.router
={
	on:{
		coming(data){ // data === views.data
			console.log("Sketch page data:", data);
			let sketch = SketchList[data.page - 1];

			sf.model('header').cloneActive = sketch.page.cloneActive;
			$('body > .background .tile').css('display', 'none');

			if(sketch.ifaceList.length === 0 && !sketch.__importing)
				sketch.page.panels.bottom.openPanel();
		},
		leaving(){
			console.log("Leaving from sketch page data:", arguments);
			$('body > .background .tile').css('display', '');
		}
	}
}

## js-global
// Blackprint.space = Space (https://github.com/ScarletsFiction/ScarletsFrame/wiki)
// sketch.scope = shortcut to obtain your model scope/context
var SketchList = [];
sf.component('sketch-page', function(My){
	// URL: #page/sketch/{data.page}
	let sketch = My.sketch = SketchList[views.data.page - 1] ??= new Blackprint.Sketch();
	sketch.page = My;

	// Will be filled by each panel component after initialized
	My.panels = {left: null, bottom: null, right: null};

	// Please use sketch.on('...', callback) instead
	// This is used if no one listened to the event
	sketch._event.$_fallback = BlackprintEventFallback;

	// path: /src/global/SuggestNodeTypeCaster.js
	sketch.on('port.cable.test', {slot: 'bp-editor'}, SuggestNodeTypeCaster);
	sketch.on('port.hover node.hover', {slot: 'bp-editor'}, ev => {
		ev.instance = sketch;

		if(ev.port != null) PortHoverInfo(ev, true);
		if(ev.iface != null) NodeHoverInfo(ev, true);
	});
	sketch.on('port.unhover node.unhover', {slot: 'bp-editor'}, ev => {
		ev.instance = sketch;

		if(ev.port != null) PortHoverInfo(ev, false);
		if(ev.iface != null) NodeHoverInfo(ev, false);
	});
	sketch.on('cable.dropped', {slot: 'bp-editor'}, ev => {
		if(ev.event.ctrlKey || !ev.afterCreated) return;
		if(ev.event.target.parentNode.model !== sketch.scope('cables')) return;

		let suggestedNode = Blackprint.Sketch.suggestNodeForPort(ev.port);
		container.nodeScope.menu(ev.event, suggestedNode);

		let ifaceList = sketch.ifaceList;
		let oldLastNode = ifaceList[ifaceList.length-1];

		setTimeout(() => {
			$(sf.Window).once('pointerup', function(){
				setTimeout(() => {
					let lastNode = ifaceList[ifaceList.length-1];
					if(oldLastNode === lastNode) return;

					let owner = ev.cable.owner;
					let sourcePort = owner.source;
					let targetPorts = lastNode[sourcePort === 'input' ? 'output' : 'input'];
					let compatiblePorts = [];

					if(targetPorts == null) return;

					for(let key in targetPorts){
						if(key === '_list') continue; // ToDo: remove this after the engine get updated

						let port = targetPorts[key];
						if(isConnectablePort(owner.type, port.type))
							compatiblePorts.push(port);
					}
					
					// Auto connect if found only one compatible port
					if(compatiblePorts.length === 1){
						compatiblePorts[0].connectCable(ev.cable);

						// ToDo: remove this after Blackprint Sketch was updated
						if(sourcePort === 'input'){
							let port = compatiblePorts[0];
							let rect = port.findPortElement(targetPorts._list.getElement(port)).getBoundingClientRect();
			
							let { offset, pos, scale } = port._scope('container');
							ev.cable.head1[0] = (rect.x + rect.width/2 - offset.x - pos.x) / scale;
							ev.cable.head1[1] = (rect.y + rect.height/2 - offset.y - pos.y) / scale;
						}
					}
				}, 100);
			});
		}, 200);
	});

	// This may cause one memory leak because this will never being cleared
	// But will only be replaced if the user is clicked other nodes
	sketch.on('node.click', {slot: 'bp-editor'}, ev => {
		My.panels.right.selectNode(ev.iface);
		NodeHoverInfo(ev, false);
	});

	Blackprint.settings('visualizeFlow', true);
	My.space ??= sketch.cloneContainer();

	let SketchPages = sf.model('sketch-pages');
	let container = sketch.scope('container');
	let header = sf.model('header');

	container.hideUnusedPort = sf.model('sketch-settings').hideUnusedPort;

	container.onScale = function(scale){
		header.info.scale = Math.round(scale * 100);
	}

	// Will run when <sketch-page> inserted on DOM
	My.init = async function(){
		let sfm = $(My.space.firstElementChild);
		if(!sfm.eq(0).hasClass('bg-tile')){
			sfm.prepend('<div class="bg-tile"></div>');
		}
	}

	My.importJSON = json => sketch.importJSON(json);
	My.clearNodes = ()=> sketch.clearNodes();

	My.cloneActive = false;
	My.cloneContainer = function(){
		My.cloneActive = !My.cloneActive;

		if(My.cloneActive){
			if(My.disableVFXActive === false)
				My.disableVFX();

			// Reset current container view
			var container = sketch.scope('container');
			container.pos.x = 0;
			container.pos.y = 0;
			container.scale = 1; // 100% scale

			var mini;
			if(container.minimap)
				mini = container.minimap;
			else{
				mini = sketch.cloneContainer(true); // Clone and get the MiniMap

				// Remove the dropdown from minimap
				$('sf-m[name="dropdown"]', mini).remove();
			}

			// Clone into new window
			new sf.Window({
				title: "Cloned Sketch Container",
				templateHTML: sketch.cloneContainer() // Clone 2
			}, refreshViewport);

			// Put the mini container into DOM
			SketchPages.miniViewer.topRight = mini;

			// Refresh mini viewport size
			// I put it like this for a reason
			refreshViewport();
			function refreshViewport(){
				setTimeout(function(){
					container.pos.x = -0.1;
					setTimeout(function(){
						container.pos.x = 0;
					}, 500);
				}, 1000);
			}
		}
		else{
			SketchPages.miniViewer.topRight = null;
			sf.Window.destroy();
		}
	}

	sketch.on('node.menu', function({ iface, menu }){
		menu.unshift({
			title: !iface.id ? "Add ID" : "Modify ID",
			async callback(){
				let ref = await Swal.fire({
					title: "Write the new ID here",
					text: (iface.id ? "Current ID: "+iface.id : void 0),
					input: "text",
				});

				if(ref.isConfirmed === false) return;

				let sketch = SketchList[0];
				let val = ref.value;

				if(val === ''){
					delete sketch.iface[iface.id];
					iface.id = val;
					return;
				}

				if(sketch.iface[val] !== void 0)
					throw new Error("ID already exist");

				iface.id = val;
				sketch.iface[val] = iface;
			}
		}, {
			title: "View source code",
			async callback(){
				let code = await utils.openNodeSource(iface);
				if(!code) return;

				let editor = sf.model('custom-node-editor');
				editor.setValue(code);

				Modal.goto('/custom-node-editor');
			}
		});
	});
});