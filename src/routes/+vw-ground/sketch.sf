## html
<sf-m name="sketch-pages">
	<!-- /src/routes/+vw-ground/sketch.sf -->
	<vw-page></vw-page>
</sf-m>

## js-global.router
={
	on:{
		showed(){
			// Show sketch options
			sf.model('header').showOptions = true;
		},
		hidden(){
			sf.model('header').showOptions = false;
		}

		/*
		showed: Sketch container have been loaded,
		coming: The cable would have wrong position because the DOM still hidden,
		leaving: Maybe we can uninitialize something,
		hidden: Animate something maybe
		*/
	}
}

## scss-global
vw-page{
	position: absolute;
	height: 100%;
	width: 100%;

	&.page-current{
		top: 0;
	}
}

## js-global
sf.model('sketch-pages', function(My){
	function checkIfHasSelection(ev, skipSelectionCheck){
		// Skip textbox/input element
		let tagName = ev.target.tagName;
		if(tagName === 'INPUT' || tagName === 'TEXTAREA')
			return;

		let sketch = CurrentSketch;
		let container = sketch.scope('container');

		// Skip if no selected nodes/cables
		if(!skipSelectionCheck && container.nodeScope.selected.length === 0
		&& container.cableScope.selected.length === 0){
			return;
		}

		return {sketch, container};
	}

	if(My._eventOnce == null){
		My._eventOnce = true;
		let pointerX, pointerY;

		$(window).on('keydown', async (ev) => {
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;

			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			if(ev.key === 'Delete'){
				let selected = container.nodeScope.selected;

				for(let i=0; i < selected.length; i++)
					sketch.deleteNode(selected[i]);
			}
		})
		.on('pointermove', function(ev){
			pointerX = ev.clientX;
			pointerY = ev.clientY;
		})
		.on('copy', function(ev){
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;
			
			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			let data = sketch.exportJSON({selectedOnly: true});
			data = JSON.parse(data);

			// Find lowest position value
			let x = Infinity, y = Infinity;
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					if(node.x < x) x = node.x;
					if(node.y < y) y = node.y;
				}
			}

			if(x === Infinity) x = 0;
			if(y === Infinity) y = 0;

			// Reduce nodes positions
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x -= x;
					node.y -= y;
				}
			}

			ev.clipboardData.setData('text/plain', JSON.stringify(data));
			ev.preventDefault();
		})
		.on('paste', async function(ev){
			let passed = checkIfHasSelection(ev, true);
			if(!passed) return;
			let {sketch, container} = passed;

			let data = ev.clipboardData.getData('text/plain');
			data = JSON.parse(data);

			let {x, y} = container.pos; // Negative value
			let {x: oX, y: oY} = container.offset; // Negative value

			// Reposition the nodes near the pointer or current container
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x += -x - oX + pointerX;
					node.y += -y - oY + pointerY;
				}
			}

			let lastIndex = container.nodeScope.list.length;
			await sketch.importJSON(data, {appendMode: true});

			let { cableScope, nodeScope } = container;
			cableScope.selected.forEach(v => v.selected = false);
			cableScope.selected.splice(0);

			nodeScope.selected.forEach(v => v._nodeSelected = false);
			nodeScope.selected.splice(0);
			nodeScope.selected.push(...nodeScope.list.slice(lastIndex));
			nodeScope.selected.forEach(v => v._nodeSelected = true);
		});
	}
});