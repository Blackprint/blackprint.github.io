## html
<sf-m name="sketch-pages">
	<sf-template path="BPEditor/model/project-panel-left.sf"></sf-template>

	<!-- /src/routes/+vw-ground/sketch.sf -->
	<vw-page></vw-page>
</sf-m>

## js-global.router
={
	on:{
		showed(){
			// Show sketch options
			sf.model('header').showOptions = true;
		},
		hidden(){
			sf.model('header').showOptions = false;
		}

		/*
		showed: Sketch container have been loaded,
		coming: The cable would have wrong position because the DOM still hidden,
		leaving: Maybe we can uninitialize something,
		hidden: Animate something maybe
		*/
	}
}

## scss-global
vw-page{
	position: absolute;
	height: 100%;
	width: 100%;

	&.page-current{
		top: 0;
	}
}

## js-global
sf.model('sketch-pages', function(My){
	function checkIfHasSelection(ev, skipSelectionCheck){
		// Skip textbox/input element
		let tagName = ev.target.tagName;
		if(tagName === 'INPUT' || tagName === 'TEXTAREA') return;

		let sketch = window.CurrentSketch;
		if(sketch == null) return;

		let container = sketch.scope('container');

		// Skip if no selected nodes/cables
		if(!skipSelectionCheck && container.nodeScope.selected.length === 0 && container.cableScope.selected.length === 0)
			return;

		return {sketch, container};
	}

	if(My._eventOnce == null){
		My._eventOnce = true;
		let pointerX, pointerY;

		My.skipMenuHandler = false;
		Blackprint.on('menu.create.node', function({ menu, position, options, event, preventDefault }){
			if(My.skipMenuHandler) return;
			preventDefault();

			position.event = event;

			// Check if doing region select when opening this context menu
			let container = CurrentSketch.scope('container');
			if(container.select.w > 30 || container.select.h > 30){
				let { x, y, w, h, ix, iy } = container.select;

				if(ix) x = obj.x - obj.w;
				if(iy) y = obj.y - obj.h;

				position.title = "Region Select";
				DropDown.show([{
					title: "Create a group region",
					description: "A region marker where you can move all nodes as a group",
					callback(){
						let iface = CurrentSketch.createNode('Decoration/Group/Default', {
							x, y: y-21, data: {width: w, height: h+21, title: "No title"},
						});

						iface.refreshContent();
						iface.swapZIndex(); // simulate click
					},
				}], position);
				return;
			}

			position.hasSearch = true;
			position.searchObject = Blackprint._docs;
			position.title = "Create Node";

			sort(menu);
			function sort(obj){
				obj.sort((a, b) => a.title.localeCompare(b.title));
				for (let i=0; i < obj.length; i++) {
					if(obj.deep != null) sort(obj.deep);
				}
			}

			DropDown.show(menu, position);
		});

		$(window).on('keydown', async (ev) => {
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;

			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0 && container.cableScope.selected.length === 0) return;

			if(ev.key === 'Delete'){
				let selected = container.nodeScope.selected;
				for(let i=0; i < selected.length; i++)
					sketch.deleteNode(selected[i]);

				selected.splice(0);

				selected = container.cableScope.selected;
				for(let i=0; i < selected.length; i++)
					selected[i].disconnect();

				selected.splice(0);
			}
		})
		.on('pointermove', function(ev){
			pointerX = ev.clientX;
			pointerY = ev.clientY;
		})
		.on('copy', function(ev){
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;
			
			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			let data = sketch.exportJSON({
				selectedOnly: true,
				environment: false,
				exportFunctions: false,
				exportVariables: false,
			});
			data = JSON.parse(data);

			// Find lowest position value
			let instance = data.instance;
			let x = Infinity, y = Infinity;
			for(let key in instance){
				let val = instance[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					if(node.x < x) x = node.x;
					if(node.y < y) y = node.y;
				}
			}

			if(x === Infinity) x = 0;
			if(y === Infinity) y = 0;

			// Reduce nodes positions
			for(let key in instance){
				let val = instance[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x -= x;
					node.y -= y;
				}
			}

			ev.clipboardData.setData('text/plain', JSON.stringify(data));
			ev.preventDefault();
		})
		.on('paste', async function(ev){
			let passed = checkIfHasSelection(ev, true);
			if(!passed) return;
			let {sketch, container} = passed;

			let data = ev.clipboardData.getData('text/plain');
			data = JSON.parse(data);

			let {x, y} = container.pos; // Negative value
			let {x: oX, y: oY} = container.offset; // Negative value
			let scale = container.scale; // Negative value

			// Reposition the nodes near the pointer or current container
			let instance = data.instance;
			for(let key in instance){
				let val = instance[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x += (-x - oX + pointerX) / scale;
					node.y += (-y - oY + pointerY) / scale;
				}
			}

			let lastIndex = container.nodeScope.list.length;
			await sketch.importJSON(data, {appendMode: true});

			let { cableScope, nodeScope } = container;
			cableScope.selected.forEach(v => v.selected = false);
			cableScope.selected.splice(0);

			nodeScope.selected.forEach(v => v._nodeSelected = false);
			nodeScope.selected.splice(0);
			nodeScope.selected.push(...nodeScope.list.slice(lastIndex));
			nodeScope.selected.forEach(v => v._nodeSelected = true);
		});
	}
});