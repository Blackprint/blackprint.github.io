## html
<sf-m name="sketch-pages">
	<!-- /src/routes/+vw-ground/sketch.sf -->
	<vw-page></vw-page>

	<div class="mini-blackprint disable-effect {{ miniViewer.topRightHidden && 'hidden' }}">
		<!-- Will be replaced with element returned by Blackprint.cloneContainer(true) -->
		<sf-slot for="miniViewer.topRight"></sf-slot>
	</div>
</sf-m>

## js-global.router
={
	on:{
		showed(){
			// Show sketch options
			sf.model('header').showOptions = true;
		},
		hidden(){
			sf.model('header').showOptions = false;
		}

		/*
		showed: Sketch container have been loaded,
		coming: The cable would have wrong position because the DOM still hidden,
		leaving: Maybe we can uninitialize something,
		hidden: Animate something maybe
		*/
	}
}

## scss-global
vw-page{
	position: absolute;
	height: 100%;
	width: 100%;

	&.page-current{
		top: 0;
	}
}
.mini-blackprint{
	width: 240px;
	height: 190px;
	position: absolute;
	top: 5px;
	right: 0;
	overflow: hidden;
	box-shadow: 0 0 6px #ffffff6b;
	background: #ffffff40;
	border-radius: 10px;
	pointer-events: none;

	&.hidden{
		display: none;
	}
}

## js-global
sf.model('sketch-pages', function(My){
	My.miniViewer = {
		topRight: null,
		topRightHidden: true,
		on$topRight(now){
			if(now === null)
				return My.miniViewer.topRightHidden = true;

			My.miniViewer.topRightHidden = false;
			// now => <sf-space>
			// $(now)
		}
	};

	function checkIfHasSelection(ev, skipSelectionCheck){
		// Skip textbox/input element
		let tagName = ev.target.tagName;
		if(tagName === 'INPUT' || tagName === 'TEXTAREA')
			return;

		let pageIndex = views.currentPath.match(/\/sketch\/([0-9]+)/)?.[1];
		if(pageIndex == null) return;

		let sketch = SketchList[pageIndex-1];
		let container = sketch.scope('container');

		// Skip if no selected nodes/cables
		if(!skipSelectionCheck && container.nodeScope.selected.length === 0
		&& container.cableScope.selected.length === 0){
			return;
		}

		return {sketch, container};
	}

	if(My._eventOnce == null){
		My._eventOnce = true;

		$(window).on('keydown', async (ev) => {
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;

			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			if(ev.key === 'Delete'){
				let selected = container.nodeScope.selected;

				for(let i=0; i < selected.length; i++)
					sketch.deleteNode(selected[i]);
			}
		})
		.on('copy', function(ev){
			let passed = checkIfHasSelection(ev);
			if(!passed) return;
			let {sketch, container} = passed;
			
			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			let data = sketch.exportJSON({selectedOnly: true});
			data = JSON.parse(data);

			// Find lowest position value
			let x = Infinity, y = Infinity;
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					if(node.x < x) x = node.x;
					if(node.y < y) y = node.y;
				}
			}

			if(x === Infinity) x = 0;
			if(y === Infinity) y = 0;

			// Reduce nodes positions
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x -= x;
					node.y -= y;
				}
			}

			ev.clipboardData.setData('text/plain', JSON.stringify(data));
			ev.preventDefault();
		})
		.on('paste', async function(ev){
			let passed = checkIfHasSelection(ev, true);
			if(!passed) return;
			let {sketch, container} = passed;
			
			// Currently we only support copy/paste/delete for nodes
			if(container.nodeScope.selected.length === 0) return;

			let data = ev.clipboardData.getData('text/plain');
			data = JSON.parse(data);

			let {x, y} = container.pos; // Negative value

			// Reposition the nodes near the pointer or current container
			for(let key in data){
				if(key === '_') continue;

				let val = data[key];
				for(let i=0; i < val.length; i++){
					let node = val[i];
					node.x -= x;
					node.y -= y;
				}
			}

			let lastIndex = container.nodeScope.list.length;
			await sketch.importJSON(data, {appendMode: true});

			let { cableScope, nodeScope } = container;
			cableScope.selected.forEach(v => v.selected = false);
			cableScope.selected.splice(0);

			nodeScope.selected.forEach(v => v._nodeSelected = false);
			nodeScope.selected.splice(0);
			nodeScope.selected.push(...nodeScope.list.slice(lastIndex));
			nodeScope.selected.forEach(v => v._nodeSelected = true);
		});
	}
});